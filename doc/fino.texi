\input texinfo @c -*-texinfo-*-
@c %**start of header
@documentencoding UTF-8

@setfilename fino.info
@c @include version.texi
@set UPDATED April 16th, 2020
@set VERSION v0.7

@copying
This manual is for fino (version @value{VERSION}, @value{UPDATED}),
which is a completely free-as-in-freedom finite-element
thermo-mechancial solver desinged and implemented following the UNIX
principles.

Copyright @copyright{} 2016-2020 Jeremy Theler.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Fino
@subtitle a free finite-element thermo-mechanical solver, v0.7
@author Jeremy Theler
April 16th, 2020
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top
@top Fino

@menu
* Overview::
* Running fino::
* Test case::
* Reference::
@end menu

@node Overview
@chapter Overview
@anchor{#overview}
Fino is a free and open source tool released under the terms of the
GPLv3+ that uses the finite-element method to solve

@itemize
@item
steady or quasistatic thermo-mechanical problems, or
@item
steady or transient heat conduction problems, or
@item
modal analysis problems.
@end itemize

@float
@image{fino-logo,,,Updates, examples, V&V cases and full reference:
@url{https://www.seamplex.com/fino},}
@caption{Updates, examples, V&V cases and full reference:
@url{https://www.seamplex.com/fino}}
@end float

@node Running fino
@chapter Running @code{fino}
@anchor{#running-fino}

@menu
* Invocation::
* Example input files::
@end menu

@node Invocation
@section Invocation
@anchor{#invocation}
The format for running the @code{fino} program is:

@smallformat
@verbatim
fino [options] inputfile [optional_extra_arguments]...
@end verbatim
@end smallformat

The @code{fino} executable supports the following options:

@table @asis
@item @code{-d} or @code{--debug}

Start in debug mode

@item @code{--node-debug}

Ignore standard input, avoid debug mode

@item @code{-l} or @code{--list}

List defined symbols and exit

@item @code{-h} or @code{--help}

Display this help and exit

@item @code{-i} or @code{--info}

Display detailed code information and exit

@item @code{-v} or @code{--version}

Display version information and exit

@item @code{--mumps}

use the MUMPS direct solver (if available)

@item @code{--progress}

print ASCII progress bars for build, step and stress steps

@item @code{--petsc <option[=argument]>}

Pass @code{-option argument} directly to PETSc/SLEPc, e.g.

@smallformat
@verbatim
$ fino tensile-test.fin --petsc ksp_view
@end verbatim
@end smallformat

The option @code{--petsc} is provided to avoid clashes with PETSc'
non-POSIX arguments. Note that options are passed directly to
PETSc/SLEPc if they do not clash with Fino/wasora. The same command as
above could have been called as

@smallformat
@verbatim
$ fino tensile-test.fin -ksp_view
@end verbatim
@end smallformat

@end table

Input file instructions are read from standard input if a dash @code{-}
is passed as @code{input-file}.

Fino accepts @emph{optional extra arguments} which are then verbatimly
replaced in the input file as @code{$1}, @code{$2}, and so on. So for
example if an input file has a line like this

@smallformat
@verbatim
MESH_FILE $1.msh
[...]
@end verbatim
@end smallformat

Then two different meshes called @code{one.msh} and @code{two.msh} can
successively be used in two runs with the same input file by calling
Fino as

@smallformat
@verbatim
fino input.fin one
fino input.fin two
@end verbatim
@end smallformat

@node Example input files
@section Example input files
@anchor{#example-input-files}

@menu
* Minimum working example::
* Extended annotated example::
@end menu

@node Minimum working example
@subsection Minimum working example
@anchor{#minimum-working-example}
The following is a MWE input file for Fino that reads a Gmsh-generated
@code{.msh} file, solves a linear elastic problem and wriets the results
in a @code{.vtk} file which can be post-processed by Paraview:

@smallformat
@verbatim
MESH FILE_PATH tensile-test.msh  # mesh file in Gmsh format

E = 200e3   # [ MPa ] Young modulus ~ 200 GPa
nu = 0.3    # Poisson ratio

# boundary conditions ("left" and "right" come from the names in the mesh)
PHYSICAL_GROUP left  BC fixed
PHYSICAL_GROUP right BC Fx=1e4      # [ N ] load in x+

FINO_STEP   # solve

# write results (Von Mises, principal and displacements) in a VTK file
MESH_POST FILE_PATH tensile-mwe.vtk sigma sigma1 sigma2 sigma3 VECTOR u v w
@end verbatim
@end smallformat

@node Extended annotated example
@subsection Extended annotated example
@anchor{#extended-annotated-example}
The example can be extended to give more information as the following
annotated input shows:

@smallformat
@verbatim
# tensile test example for Fino, see https://caeplex.com/p/41dd1
MESH FILE_PATH tensile-test.msh  # mesh file in Gmsh format (either version 2.2 or 4.x)

# uniform properties given as scalar variables
E = 200e3   # [ MPa ] Young modulus = 200 GPa
nu = 0.3    # Poisson’s ratio

# boundary conditions ("left" and "right" come from the names in the mesh)
PHYSICAL_GROUP left  BC fixed       # fixed end
PHYSICAL_GROUP right BC Fx=1e4      # [ N ] load in x+

FINO_SOLVER PROGRESS_ASCII  # print ascii progress bars (optional) 
# FINO_SOLVER KSP mumps       # try to use mumps (if it is not available gamg+gmres is used)
FINO_STEP                   # solve

# compute reaction force at fixed end
FINO_REACTION PHYSICAL_GROUP left RESULT R

# write results (Von Mises, principal and displacements) in a VTK file
MESH_POST FILE_PATH tensile-test.vtk delta_sigma sigma sigma1 sigma2 sigma3 VECTOR u v w

# print some results (otherwise output will be null)
PRINT SEP " " "displ_max =" %.3f displ_max "mm"
PRINT SEP " " "sigma_max = (" %.1f sigma_max "±" delta_sigma_max ") MPa"
PRINT SEP " " "principal1 at center = (" %.5f sigma1(0,0,0) "±" delta_sigma(0,0,0) ") MPa"
PRINT SEP " " "reaction  = [" %.3e R "] Newtons"
PRINT FILE_PATH tensile-sigma.dat %.0f sigma(0,0,0)
@end verbatim
@end smallformat

@node Test case
@chapter Test case
@anchor{#test-case}
This first case serves as a basic example to answer the first validation
question: does Fino do what a FEA program is supposed to do? It also
illustrates its design basis and the
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html,philosophy}
behind its implementation. A quotation from
@uref{http://www.catb.org/esr/,Eric Raymond}'s
@uref{http://www.catb.org/esr/writings/taoup/,The Art of Unix
Programming} helps to illustrate this idea:

@quotation
@uref{https://en.wikipedia.org/wiki/Douglas_McIlroy,Doug McIlroy}, the
inventor of @uref{https://en.wikipedia.org/wiki/Pipeline_%28Unix%29,Unix
pipes} and one of the founders of the
@uref{https://en.wikipedia.org/wiki/Unix,Unix tradition}, had this to
say at the time:

@enumerate 
@item
Make each program do one thing well. To do a new job, build afresh
rather than complicate old programs by adding new features.

@item
Expect the output of every program to become the input to another, as
yet unknown, program. Don't clutter output with extraneous information.
Avoid stringently columnar or binary input formats. Don't insist on
interactive input.

@end enumerate

[@dots{}]

He later summarized it this way (quoted in ``A Quarter Century of Unix''
in 1994):

@itemize
@item
This is the Unix philosophy: Write programs that do one thing and do it
well. Write programs to work together. Write programs to handle text
streams, because that is a universal interface.
@end itemize

@end quotation
Keep in mind that even though the quotes above and many FEA programs
that are still mainstream today date both from the early 1970s, fifty
years later they still

@itemize
@item
Do not make just only one thing well.
@item
Do complicate old programs by adding new features.
@item
Do not expect the their output to become the input to another.
@item
Do clutter output with extraneous information.
@item
Do use stringently columnar and/or binary input (and output!) formats.
@item
Do insist on interactive output.
@end itemize

A further note is that not only is Fino both
@uref{https://www.gnu.org/philosophy/free-sw.en.html,free} and
@uref{https://opensource.com/resources/what-open-source,open-source}
software but it also is designed to connect and to work with
(@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877684,rule
of composition}) other free and open source software, like
@uref{http://gmsh.info/,Gmsh},
@uref{https://www.paraview.org/,ParaView},
@uref{http://gnuplot.info/,Gnuplot},
@uref{http://www.pyxplot.org.uk/,Pyxplot},
@uref{https://pandoc.org/,Pandoc}, @uref{https://tug.org/,TeX}, and many
others, including of course the operating system
@uref{https://www.gnu.org/,GNU}/@uref{https://www.kernel.org/,Linux}. In
particular, this report has been created from scratch using free and
open source software only.

Fino also makes use of high-quality free and open source mathematical
libraries which contain numerical methods designed by mathematicians and
programmed by professional programmers, such as
@uref{https://www.gnu.org/software/gsl/,GNU Scientific Library},
@uref{https://www.mcs.anl.gov/petsc/,PETSc},
@uref{http://slepc.upv.es/,SLEPc} (optional) and all its respective
dependencies. This way, Fino bounds its scope to do only one thing and
to do it well: to build and solve finite-element formulations of
thermo-mechanical problems. And it does so on high grounds, both

@enumerate 
@item
ethical: since it is
@uref{https://www.gnu.org/philosophy/open-source-misses-the-point.en.html,free
software}, all users can

@enumerate 0
@item
run,
@item
share,
@item
modify, and/or
@item
re-share their modifications.
@end enumerate

If a user cannot read or write code to make Fino suit her needs, at
least she has the @emph{freedom} to hire someone to do it for her, and

@item
technological: since it is
@uref{http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/,open
source}, advanced users can detect and correct bugs and even improve the
algorithms. @uref{https://en.wikipedia.org/wiki/Linus%27s_law,Given
enough eyeballs, all bugs are shallow.}

@end enumerate

The reader is encouraged to consider and to evaluate the differences
(both advantages and disadvantages) between the approach proposed in
this work with traditional thermo-mechanical FEA software. The
@uref{https://git-scm.com/,Git} repository containing Fino's source code
can be found at @url{https://github.com/seamplex/fino}.

@menu
* Problem description::
* Geometry and mesh::
* Input file::
* Execution::
* Results::
* Extra checks::
@end menu

@node Problem description
@section Problem description
@anchor{#problem-description}
A tensile test specimen of nominal cross-sectional
area@ @math{A = 20~\r{mm} \times 5~\r{mm} = 100~\r{mm}^2} is fully fixed
on one end (magenta surface) and a tensile load of
@math{F_x = 10~\r{kN}} is applied at the other end (green surface). The
Young modulus is@ @math{E=200~\r{GPa}} and the Poisson's ratio
is@ @math{\nu=0.3}.

@float
@image{000-tensile-test/tensile-test-cad,12cm,,Figure 1: Tensile test
specimen CAD from CAEplex @url{https://caeplex.com/p/41dd1},png}
@caption{Figure 1: Tensile test specimen CAD from CAEplex
@url{https://caeplex.com/p/41dd1}}
@end float

@menu
* Expected results::
@end menu

@node Expected results
@subsection Expected results
@anchor{#expected-results}
The displacements and stresses distribution within the geometry are to
be obtained. Elongation along the@ @math{x} axis and a mild contraction
in@ @math{y} (and even milder in @math{z}) are expected. The normal
tension at the center of the specimen is to be checked to the
theoretical solution @math{\sigma_x = F_x/A} and the reaction at the
fixed end should balance the external load@ @math{\vec{F}} at the
opposite face. Stress concentrations are expected to occur at sharp
corners of the coupon.

@node Geometry and mesh
@section Geometry and mesh
@anchor{#geometry-and-mesh}
Following the general rule of performing only one thing well, and the
particular rules of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877684,composition}
and
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878022,parsimony},
the generation of the set of nodes and elements required to perform a
thermo-mechanical computation using the finite element method is outside
of Fino's scope. The finite-element mesh is an @emph{input} to Fino.

In the particular case of the tensile test problem, the geometry is
given as a @uref{tensile-test-specimen.step,STEP file}. It is meshed by
@uref{http://gmsh.info/,Gmsh} (or, following the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2879078,diversity},
any other meshing tool which can write meshes in
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format,MSH format}
keeping information about
@uref{http://gmsh.info/doc/texinfo/gmsh.html#Elementary-entities-vs-physical-groups,physical
groups}). A suitable mesh (fig.@ 2) can be created using the following
@code{tensile-test.geo} file:

@smallformat
@verbatim
Merge "tensile-test-specimen.step"; // read the step file
Mesh.CharacteristicLengthMax = 1.5; // set the max element size lc
Mesh.ElementOrder = 2;              // ask for second-order elements

// define physical groups for BCs and materials
// the name in the LHS has to appear in the Fino input
// the number in the RHS is the numerical id of the entity in the CAD file
Physical Surface ("left") =  {1};   // left face, to be fixed
Physical Surface ("right") =  {7};  // right face, will hold the load
Physical Volume ("bulk") =  {1};    // bulk material elements
@end verbatim
@end smallformat

Out of the six lines, the first three are used to read the CAD file, to
set the characteristic element size@ @math{\ell_c = 1.5~\r{mm}} and to
ask for second-order 10-noded tetrahedra (by default Gmsh creates
first-order 4-node tetrahedra). The last three lines define one physical
group each:

@itemize
@item
geometrical surface #1 as physical surface ``left,'' which will be set
as fixed in the Fino input file,
@item
geometrical surface #7 as physical surface ``right,'' which will hold
the load defined in the Fino input file, and
@item
the volumetric bulk material elements in geometrical volume #1.
@end itemize

@float
@image{000-tensile-test/tensile-faces,12cm,,a,svg}
@caption{a}
@end float

@float
@image{000-tensile-test/tensile-mesh,12cm,,b,png}
@caption{b}
@end float

Figure 2: Tensile test specimen CAD, its geometrical entities and the
resulting mesh.. a --- Numerical ids of the surfaces in the original
CAD., b --- Three-dimensional mesh with
uniform@ @math{\ell_c=1.5~\r{mm}} and @math{\sim} 50k nodes.
In general, multi-solid problems need to have different physical volumes
in order to Fino to be able to set different mechanical properties. Even
though this simple problem has a single solid, a physical volumetric
group is needed in order to Gmsh to write the volumetric elements
(i.e.@ tetrahedra) in the @uref{tensile-test.msh,output MSH file}.

The usage of
@uref{http://gmsh.info/doc/texinfo/gmsh.html#Elementary-entities-vs-physical-groups,physical
groups} to define boundary conditions follows the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878263,representation}
as it folds knowledge into data instead of focusing on algorithmically
setting loads on individual nodes. It also allows for
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2879112,extensibility}
since, for example, a mesh with many physical groups can be used for
both a tensile and a bending cases where the first uses some groups and
the latter other groups bringing
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877610,clarity}
to the game.

@node Input file
@section Input file
@anchor{#input-file}
Fino reads a plain-text input file---which in turns also reads the mesh
generated above---that defines the problem, asks Fino to solve it and
writes whatever output is needed. It is a
@uref{http://en.wikipedia.org/wiki/Syntactic_sugar,syntactically-sweetened}
way to ask the computer to perform the actual computation (which is what
computers do). This input file, as illustrated in the example below
lives somewhere near the English language so a person can read through
it from the top down to the bottom and more or less understand what is
going on (rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878339,least
surprise}). Yet in the extreme case that the complexity of the problem
asks for, the input file could be machine-generated by a script or a
macro (rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878742,generation}).
Or if the circumstances call for an actual graphical interface for
properly processing (both pre and post) the problem, the input file
could be created by a separate cooperating front-end such as
@uref{https://www.caeplex.com,CAEplex} in fig.@ 1 above (rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877777,separation}).
In any case, the input files---both for Gmsh and for Fino---can be
tracked with @uref{https://en.wikipedia.org/wiki/Git,Git} in order to
increase traceability and repeatability of engineering computations.
This is not true for most of the other FEA tools avaialable today,
particularly the ones that do not follow McIlroy's recommendations
above.

Given that the problem is relatively simple, following the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877917,simplicity},
the input file @uref{tensile-test.fin,@code{tensile-test.fin}} ought to
be also simple. Other cases with more complexity such as parametric runs
(such as case_link(085-cantilever-cylinder)) or those that need to read
results from other programs (such as
case_link(075-fixed-compressed-cylinder)) in order to compare results
might lead to more complex input files.

@smallformat
@verbatim
# tensile test example for Fino, see https://caeplex.com/p/41dd1
MESH FILE_PATH tensile-test.msh  # mesh file in Gmsh format (either version 2.2 or 4.x)

# uniform properties given as scalar variables
E = 200e3   # [ MPa ] Young modulus = 200 GPa
nu = 0.3    # Poisson’s ratio

# boundary conditions ("left" and "right" come from the names in the mesh)
PHYSICAL_GROUP left  BC fixed       # fixed end
PHYSICAL_GROUP right BC Fx=1e4      # [ N ] load in x+

FINO_SOLVER PROGRESS_ASCII  # print ascii progress bars (optional) 
FINO_STEP                   # solve

# compute reaction force at fixed end
FINO_REACTION PHYSICAL_GROUP left RESULT R

# write results (Von Mises, principal and displacements) in a VTK file
MESH_POST FILE_PATH tensile-test.vtk sigma sigma1 sigma2 sigma3 VECTOR u v w

# print some results (otherwise output will be null)
PRINT "displ_max = " %.3f displ_max "mm"
PRINT "sigma_max = " %.1f sigma_max "MPa"
PRINT "principal1 at center = " %.8f sigma1(0,0,0) "MPa"
PRINT "reaction  = [" %.3e R "] Newtons"
PRINT FILE_PATH tensile-sigma.dat %.0f sigma(0,0,0)
@end verbatim
@end smallformat

@itemize
@item
The mesh @uref{tensile-test.msh,@code{tensile-test.msh}} is the output
of Gmsh when invoked with the input
@uref{tensile-test.geo,@code{tensile-test.geo}} above. It can be either
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format,version@ 4.1}
or
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format-version-2-_0028Legacy_0029,2.2}.
@item
The mechanical properties, namely the Young modulus@ @math{E} and the
Poisson's ratio@ @math{\nu} are uniform in space. Therefore, they can be
simply set using special variables @code{E} and @code{nu}.
@item
Boundary conditions are set by referring to the physical surfaces
defined in the mesh. The keyword @code{fixed} is a shortcut for setting
the individual displacements in each direction @code{u=0}, @code{v=0}
and @code{w=0}.
@item
An explicit location within the logical flow of the input file hast to
be given where Fino ought to actually solve the problem with the keyword
@code{FINO_STEP}. It should be after defining the material properties
and the boundary conditions and before computing secondary results (such
as the reactions) and asking for outputs.
@item
The reaction in the physical group ``left'' is computed after the
problem is solved (i.e.@ after @code{FINO_STEP}) and the result is
stored in a vector named @code{R} of size three. There is nothing
special about the name @code{R}, it could have been any other valid
identifier name.
@item
A @uref{tensile-test.vtk,post-processing output file} in format
@uref{https://lorensen.github.io/VTKExamples/site/VTKFileFormats/,VTK}
is created, containing:
@itemize
@item
The von@ Mises stress @code{sigma} (@math{\sigma}) as an scalar field
@item
The three principal stresses @code{sigma1}, @code{sigma_2}
and@ @code{sigma_3} (@math{\sigma_1}, @math{\sigma_2} and
@math{\sigma_3} respectively) as three scalar fields
@item
The displacement vector @math{\vec{u}=[u,v,w]} as a three-dimensional
vector field
@end itemize

@item
Some results are printed to the terminal (i.e.@ the
@uref{https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout),standard
output}) to summarize the run. Note that
@enumerate 
@item
The actual output (including post-processing files) is 100% defined by
the user, and
@item
If no output instructions are given in the input file (@code{PRINT},
@code{MESH_POST}, etc.) then no output will be obtained.
@end enumerate

Not only do these two facts follow the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878450,silence}
but they also embrace the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878666,economy}:
the time needed for the user to find and process a single result in a
soup of megabytes of a cluttered output file far outweighs the cost of
running a computation from scratch with the needed result as the only
output.
@item
Finally, the von@ Mises stress@ @math{\sigma(0,0,0)} evaluated at the
origin is written to an @uref{https://en.wikipedia.org/wiki/ASCII,ASCII}
file @uref{tensile-sigma.dat,@code{tensile-sigma.dat}} rounded to the
nearest integer (in MPa). This is used to test the outcome of Fino's
self-tests using the @code{make check}
@uref{https://www.gnu.org/software/make/manual/make.html#Standard-Targets,target}
in an
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2878742,automated
way}. Note that there is no need to have an actual node at
@math{\vec{x}=(0,0,0)} since Fino (actually
@uref{https://www.seamplex.com/wasora,wasora}) can evaluate functions at
any arbitrary point.
@end itemize

@node Execution
@section Execution
@anchor{#sec:execution}
Here is a static mimic of a 22-second terminal session:

@smallformat
@verbatim
$ gmsh -3 tensile-test.geo
Info    : Running 'gmsh -3 tensile-test.geo' [Gmsh 4.5.2-git-2373007b0, 1 node, max. 1 thread]
Info    : Started on Wed Jan 29 11:07:04 2020
Info    : Reading 'tensile-test.geo'...
Info    : Reading 'tensile-test-specimen.step'...
Info    :  - Label 'Shapes/ASSEMBLY/=>[0:1:1:2]/Pad' (3D)
Info    :  - Color (0.8, 0.8, 0.8) (3D & Surfaces)
Info    : Done reading 'tensile-test-specimen.step'
Info    : Done reading 'tensile-test.geo'
Info    : Meshing 1D...
Info    : [  0 %] Meshing curve 1 (Line)
Info    : [ 10 %] Meshing curve 2 (Line)
Info    : [ 10 %] Meshing curve 3 (Line)
[...]
Info    : [100 %] Meshing surface 14 order 2
Info    : [100 %] Meshing volume 1 order 2
Info    : Surface mesh: worst distortion = 0.90913 (0 elements in ]0, 0.2]); worst gamma = 0.722061
Info    : Volume mesh: worst distortion = 0.824145 (0 elements in ]0, 0.2])
Info    : Done meshing order 2 (1.32521 s)
Info    : 49534 nodes 40321 elements
Info    : Writing 'tensile-test.msh'...
Info    : Done writing 'tensile-test.msh'
Info    : Stopped on Wed Jan 29 11:07:07 2020
$ fino tensile-test.fin
....................................................................................................
----------------------------------------------------------------------------------------------------
====================================================================================================
displ_max =     0.076   mm
sigma_max =     160.2   MPa
principal1 at center =  99.99998119     MPa
reaction  = [   -1.000e+04      -1.693e-04      -1.114e-03      ] Newtons
$
@end verbatim
@end smallformat

@itemize
@item
The three lines with the dots, dashes and double dashes are ASCII
progress bars for the assembly of the stiffness matrix, the solution of
the linear system and the computation of stresses, respectively. They
are turned on with @code{PROGRESS_ASCII}.
@item
Almost any location within the input file where a numerical value is
expected can be replaced by an algebraic expression, including standard
functions like @code{log}, @code{exp}, @code{sin}, etc. See
@uref{https://www.seamplex.com/wasora/reference.html#functions,wasora's
reference} for details.
@item
Once again, if the @code{MESH_POST} and @code{PRINT} instructions were
not included, there would not be any default output of the execution
(@uref{http://www.linfo.org/rule_of_silence.html,rule of silence}). This
should be emphasized over and over, as I have recently (i.e.@ thirteen
years after the commercial introduction of smartphones) stumbled upon a
the output file of a classical FEM program that seems to have been
executed in 1970: paginated ASCII text ready to be fed to a matrix-doy
printed containing all the possible numerical output because the CPU
cost of re-running the case of course overwhelms the hourly rate of the
engineer that hast to understand the results. For more than fifty years
(and counting), McIlroy's second bullet above has been blatantly
ignored.
@item
It has already been said that the output is 100% controlled by the user.
Yet this fact includes not just what is written but also how: the
precision of the printed results is controlled with
@uref{https://en.wikipedia.org/wiki/Printf_format_string,@code{printf}
format specifiers}. Note the eight decimal positions in the evaluation
of@ @math{\sigma_1} at the origin, whilst the expected value was
@math{100~\r{MPa}} (the load is @math{F_x=10^4~\r{N}} and the
cross-sectional area is @math{100~\r{mm}^2}).
@item
If available, the @uref{http://mumps-solver.org/,MUMPS Solver} direct
solver can be used instead of the default GAMG-preconditioned GMRES
itearative solver by passing the option @code{--mumps} in the command
line. More on solvers in sec.@ 3.6.2.
@end itemize

@node Results
@section Results
@anchor{#results}
After the problem is solved and an appropriately-formatted output file
is created, Fino's job is considered done. In this case, the
post-processing file is written using @code{MESH_POST}. The
@uref{tensile-test.vtk,VTK output} can be post-processed with the free
and open source tool @uref{http://www.paraview.org/,ParaView} (or any
other tool that reads
@uref{(https://lorensen.github.io/VTKExamples/site/VTKFileFormats/),VTK
files} such as
@uref{http://gmsh.info/doc/texinfo/gmsh.html#Post_002dprocessing,Gmsh in
post-processing mode}), as illustrated in fig.@ 3.

@float
@image{000-tensile-test/tensile-test,12cm,,Figure 3: Tensile test
results obtained by Fino and post-processed by ParaView. Displacements
are warped 500@ times.,png}
@caption{Figure 3: Tensile test results obtained by Fino and
post-processed by ParaView. Displacements are warped 500@ times.}
@end float

@menu
* Check::
@end menu

@node Check
@subsection Check
@anchor{#check}
Qualitatively speaking, Fino does what a mechanical finite-element
program is expected to do:

@itemize
@item
The displacement vector and scalar von@ Mises stress fields are computed
by Fino, as they are successfully read by Paraview.

@item
Elongation in the@ @math{x} direction and mild contractions in @math{y}
and @math{z} are observed.

@item
The principal stress @math{\sigma_1} should be equal to @math{F_x/A},
where

@itemize
@item
@math{F_x=10^4~\r{N}}, and
@item
@math{A = 20~\r{mm} \times 5~\r{mm} = 100~\r{mm}^2}.
@end itemize

In effect, @math{\sigma_1(0,0,0) = 100~\r{MPa}}.

@item
The numerical reaction @math{\vec{R}} at the fixed end reported by Fino
is

@math{
\vec{R} = \left[ -10^4 \quad \approx 10^{-4} \quad \approx 10^{-3} \right]^T ~\r{N}
}

which serves as a consistency check.

@item
Stress concentrations are obtained where they are expected.

@end itemize

@node Extra checks
@section Extra checks
@anchor{#extra-checks}
The simple tensile test problem is qualitatively solved with Fino as
expected. This section extends the validation to further check that Fino
is solving the right equations.

@menu
* Strain energy convergence::
* Performance::
@end menu

@node Strain energy convergence
@subsection Strain energy convergence
@anchor{#strain-energy-convergence}
It is a well-known result from the mathematical theory that the
displacement-based finite-element formulation gives a stiffer solution
than the continuous problem. This means that the total strain
energy@ @math{U} in load-driven (displacement-driven) problems is always
lower (higher) than the exact physical value.

The following input files asks Fino to perform a parametric run on
@math{c \in [1:10]} which controls the characteristic element
size@ @math{\ell_c=10~\r{mm}/c}:

@smallformat
@verbatim
PARAMETRIC c MIN 1 MAX 10 STEP 1
lc = 10/c
M4 INPUT_FILE_PATH parametric.geo.m4 OUTPUT_FILE_PATH parametric.geo EXPAND lc
SHELL "gmsh -3 -v 0 parametric.geo"
MESH FILE_PATH parametric.msh
E = 200e3
nu = 0.3
PHYSICAL_GROUP left  BC fixed
INCLUDE $1.fin     # include either load or displ boundary condition
FINO_STEP
FINO_REACTION PHYSICAL_GROUP left RESULT R
PRINT c lc nodes %.4f strain_energy %.8f u(80,0,0) R(1) %.8f sigma1(0,0,0) %.3f time_wall_total %e memory
@end verbatim
@end smallformat

Depending on the command-line argument @code{$1}, it includes either
@code{load.fin}

@smallformat
@verbatim
PHYSICAL_GROUP right BC Fx=1e4
@end verbatim
@end smallformat

or @code{displ.fin}

@smallformat
@verbatim
PHYSICAL_GROUP right BC u=0.075512349
@end verbatim
@end smallformat

@smallformat
@verbatim
$ fino parametric-energy.fin displ | tee displ.dat
10     10      1381    378.0254     0.07551236    -10012.19688820 100.12193130    0.393   5.705728e+07
20     5       3406    377.7806     0.07551234    -10005.87225589 100.05786431    1.416   1.020641e+08
30     3.33333 5934    377.7151     0.07551235    -10004.04718626 100.04035986    2.121   1.901896e+08
40     2.5     13173   377.6670     0.07551234    -10002.80454512 100.02703566    5.841   4.936827e+08
50     2       21897   377.6416     0.07551235    -10002.10898755 100.02189744    9.199   9.886843e+08
60     1.66667 36413   377.6316     0.07551234    -10001.84996627 100.01824358    20.676  1.319252e+09
70     1.42857 52883   377.6141     0.07551235    -10001.38248904 100.01358953    24.926  2.285650e+09
80     1.25    71568   377.6106     0.07551236    -10001.29858951 100.01271875    38.768  2.688750e+09
90     1.11111 103742  377.6026     0.07551235    -10001.09116871 100.01066954    67.782  3.595817e+09
100    1       136906  377.5994     0.07551234    -10000.99998694 100.00974332    90.248  4.684169e+09
$ fino parametric-energy.fin load | tee load.dat 
10     10      1381    377.0997     0.07538952    -10000.00057800 99.99985582     0.826   5.935514e+07
20     5       3406    377.3440     0.07542967    -9999.99727028  99.99965822     2.036   1.042063e+08
30     3.33333 5934    377.4100     0.07544179    -10000.00700660 99.99980990     2.541   1.924178e+08
40     2.5     13173   377.4580     0.07545095    -9999.95509637  99.99981492     6.251   4.988027e+08
50     2       21897   377.4829     0.07545594    -9999.99976796  99.99974599     7.323   9.938166e+08
60     1.66667 36413   377.4938     0.07545809    -9999.97099411  99.99987546     14.838  1.328071e+09
70     1.42857 52883   377.5105     0.07546140    -9999.95702214  100.00028774    25.190  2.294686e+09
80     1.25    71568   377.5145     0.07546216    -9999.97300192  99.99997997     33.983  2.697781e+09
90     1.11111 103742  377.5201     0.07546350    -10000.04369761 99.99955431     45.707  3.604849e+09
100    1       136906  377.5267     0.07546443    -9999.93061385  100.00001476    99.697  4.685390e+09
$
@end verbatim
@end smallformat

@float
@image{000-tensile-test/energy,12cm,,Figure 4: Total strain
energy@ @math{U} computed by Fino as a function of the number of nodes
for load and displacement-driven problems.,svg}
@caption{Figure 4: Total strain energy@ @math{U} computed by Fino as a
function of the number of nodes for load and displacement-driven
problems.}
@end float

Indeed, fig.@ 4 shows that the total strain energy@ @math{U} is a
monotonically increasing function of the number of nodes. Conversely,
for the load-driven case it is monotonically decreasing, which is the
expected behavior of a displacement-based finite-element program.

@node Performance
@subsection Performance
@anchor{#sec:performance}
Let's switch our attention briefly to the subject of performance, which
is indeed related to what it is expected from a finite-element program.
In the general case, the time needed to solve a finite-element problem
depends on

@enumerate 
@item
the size of the problem being solved,
@enumerate a
@item
the number of the nodes in the mesh
@item
the number of degrees of freedom per node of the problem
@end enumerate

@item
the particular problem being solved,
@enumerate a
@item
the condition number of the stiffness matrix
@item
the non-zero structure of the stiffness matrix
@end enumerate

@item
the computer used to solve the problem,
@enumerate a
@item
the architecture, frequency and number of the CPU(s)
@item
the size, speed and number of memory cache levels
@item
implementation details of the operating-system scheduler
@end enumerate

@item
the optimization flags used to compile the code
@item
the algorithms used to solve the system of equations
@enumerate a
@item
preconditioner
@item
linear solver
@item
parallelization (or lack of)
@end enumerate

@end enumerate

As it has been already explained, Fino uses
@uref{https://www.mcs.anl.gov/petsc/,PETSc}---pronounced PET-see (the S
is silent). It is a suite of data structures and routines for the
scalable (parallel) solution of scientific applications modeled by
partial differential equations. In other words, it is a library
programmed by professional programmers implementing state-of-the-art
numerical methods developed by professional mathematicians. And yet, it
is @uref{https://www.mcs.anl.gov/petsc/documentation/license.html,free
and open source} software.

PETSc provides a variety of
@uref{https://www.mcs.anl.gov/petsc/documentation/linearsolvertable.html,linear
solvers and preconditioners} which can be used to solve the
finite-element formulation. The choice of the type of preconditioner and
linear solver can be done from the input file or directly from the
command line. By default, mechanical problems are solved with the
@uref{https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCGAMG.html,Geometric
algebraic multigrid}-preconditioned
@uref{https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPGMRES.html,Generalized
Minimal Residual method}, which is an iterative solver. An alternative
might be a direct sparse solver, such as the
@uref{http://mumps-solver.org/,MUMPS Solver}, which Fino (through
PETSc's interface) can use.

To get some insight about how the problem size, the computer and the
algorithms impact in the time needed to solve the problem we perform
another parametric run on@ @math{c \in [1:12]} in two different
computers with three different solvers and pre-conditioners:

@enumerate 
@item
Geometric Algebraic Multigrid preconditioner with Generalized Minimal
Residual solver (default)
@item
LU direct solver used as a preconditoner
@item
Cholesky-preconditioned direct MUMPS solver
@end enumerate

@smallformat
@verbatim
FINO_SOLVER PC_TYPE $1    # either gamg, lu or mumps (read from commandline)
PARAMETRIC c MIN 1 MAX 12 STEP 1
lc = 10/c
FILE msh parametric-%d.msh c
MESH FILE msh
E = 200e3
nu = 0.3
PHYSICAL_GROUP left  BC fixed
PHYSICAL_GROUP right BC Fx=1e4
FINO_STEP
PRINT c lc nodes %e time_wall_total memory time_wall_build time_wall_solve time_wall_stress 
@end verbatim
@end smallformat

@smallformat
@verbatim
$ for i in gamg lu mumps; do fino parametric-solver.fin $i > `hostname`-${i}.dat; done
$
@end verbatim
@end smallformat

@float
@image{000-tensile-test/tom,12cm,,a,svg}
@caption{a}
@end float

@float
@image{000-tensile-test/vps,12cm,,b,svg}
@caption{b}
@end float

Figure 5: Wall time needed to solve the linear problem as a function of
the number of nodes in two different computers. a --- High-end desktop
computer, b --- Virtual server running on the cloud
Fig.@ 5 shows the dependence of the
@uref{https://en.wikipedia.org/wiki/Elapsed_real_time,wall time} needed
to solve the linear problem with respect to the number of nodes in two
different computers. Only the time needed to solve the linear problem is
plotted. That is to say, the time needed to mesh the geometry, to build
the matrix and to compute the stresses out of the displacements is not
taken into account. The reported times correspond to only one process,
i.e.@ Fino is run in serial mode with no parallelization requested. It
can be seen that direct solvers are faster than the iterative method for
small problems. Yet GAMG scales better and for a certain problem size
(which depends on the hardware and more importantly on the particular
problem being solved) its performance is better than that of the direct
solvers. This is a known result, which can be stated as direct solvers
are @emph{robust} but @emph{not scalable}.@footnote{See second bullet of
slide #6 in
@url{http://www.mcs.anl.gov/petsc/petsc-20/tutorial/PETSc3.pdf}.}

Fino defaults to GAMG+GMRES since this combination is provided natively
by PETSc and does not need any extra library (as in the MUMPS case), but
it still sticks to the rule of
@uref{https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#rule_of_optimization,optimization}.
Chances are that another combination of preconditioner, solver (and
hardware!) might be better suitable for the problem being solved. It is
up to the user to measure and to choose the most convenient
configuration to obtain results as efficiently as possible.

@float
@image{000-tensile-test/strong,12cm,,Figure 6: Wall time for strong
parallel scaling test.,svg}
@caption{Figure 6: Wall time for strong parallel scaling test.}
@end float

@node Reference
@chapter Reference
@anchor{#reference}

@menu
* Fino keywords::
* Mesh keywords::
* Special input distributions::
* Boundary conditions::
* Result functions::
* Wasora keywords::
* Fino variables::
@end menu

@node Fino keywords
@section Fino keywords
@anchor{#fino-keywords}

@menu
* FINO_LINEARIZE::
* FINO_PROBLEM::
* FINO_REACTION::
* FINO_SOLVER::
* FINO_STEP::
@end menu

@node FINO_LINEARIZE
@subsection FINO_LINEARIZE
@anchor{#fino_linearize}
@quotation
Performs stress linearization according to ASME VII-Sec 5 over a Stress
Classification Line
@end quotation

@smallformat
@verbatim
FINO_LINEARIZE { PHYSICAL_GROUP <physical_group> | START_POINT <x1> <y1> <z1> END_POINT <x2> <y2> <z2> }
 [ FILE <file_id> | FILE_PATH <file_path> ]
 [ TOTAL { vonmises tresca | tresca | principal1 | principal2 | principal3 }
 [ M <variable> ]
 [ MB <variable> ]
 [ PEAK <variable> ]
@end verbatim
@end smallformat

The Stress Classification Line (SCL) may be given either as a
one-dimensional physical group in the mesh or as the (continuous)
spatial coordinates of two end-points. If the SCL is given as a
@code{PHYSICAL_GROUP}, the entity should be one-dimensional (i.e a line)
independently of the dimension of the problem. If the SCL is given with
@code{START_POINT} and @code{END_POINT}, the number of coordinates given
should match the problem dimension (i.e three coordinates for full@ 3D
problems and two coordinates for axisymmetric or plane problems).
Coordinates can be given algebraic expressions that will be evaluated at
the time of the linearization. If either a @code{FILE} or a
@code{FILE_PATH} is given, the total, membrane and membrane plus bending
stresses are written as a function of a scalar @math{t \in [0,1]}.
Moreover, the individual elements of the membrane and bending stress
tensors are written within comments (i.e.@ lines starting with the hash
symbol @code{#}). By default, the linearization uses the Von@ Mises
criterion for the composition of stresses. The definition of what
@emph{total stress} means can be changed using the @code{TOTAL} keyword.
The membrane, bending and peak stress tensor elements are combined using
the Von@ Mises criterion and stored as variables. If no name for any of
the variables is given, they are stored in @code{M_group},
@code{B_group} and @code{P_group} respectively if there is a physical
group. Otherwise @code{M_1}, @code{B_1} and @code{P_1} for the first
instruction, @code{M_2}@dots{} etc.

@node FINO_PROBLEM
@subsection FINO_PROBLEM
@anchor{#fino_problem}
@quotation
Sets the problem type that Fino has to solve.
@end quotation

@smallformat
@verbatim
FINO_PROBLEM [ mechanical | thermal | modal ]
 [ AXISYMMETRIC | PLANE_STRESS | PLANE_STRAIN ] [ SYMMETRY_AXIS { x | y } ] [ LINEAR | NON_LINEAR ]
 [ QUASISTATIC | TRANSIENT ]
 [ DIMENSIONS <expr> ] [ MESH <identifier> ] 
 [ N_MODES <expr> ] 
@end verbatim
@end smallformat

@itemize
@item
@code{mechanical} (or @code{elastic} or @code{break}, default) solves
the mechanical elastic problem (default).
@item
@code{thermal} (or @code{heat} or @code{bake}) solves the heat
conduction problem.
@item
@code{modal} (or @code{shake}) computes the natural frequencies and
oscillation modes.
@end itemize

If the @code{AXISYMMETRIC} keyword is given, the mesh is expected to be
two-dimensional in the @math{x}-@math{y} plane and the problem is
assumed to be axi-symmetric around the axis given by
@code{SYMMETRY_AXIS} (default is @math{y}). If the problem type is
mechanical and the mesh is two-dimensional on the @math{x}-@math{y}
plane and no axisymmetry is given, either @code{PLANE_STRESS} and
@code{PLAIN_STRAIN} can be provided (default is plane stress). By
default Fino tries to detect wheter the computation should be linear or
non-linear. An explicit mode can be set with either @code{LINEAR} on
@code{NON_LINEAR}. The number of spatial dimensions of the problem needs
to be given either with the keyword @code{DIMENSIONS} or by defining a
@code{MESH} (with an explicit @code{DIMENSIONS} keyword) before
@code{FINO_PROBLEM}. If there are more than one @code{MESH}es define,
the one over which the problem is to be solved can be defined by giving
the explicit mesh name with @code{MESH}. By default, the first mesh to
be defined in the input file is the one over which the problem is
solved. The number of modes to be computed in the modal problem. The
default is DEFAULT_NMODES.

@node FINO_REACTION
@subsection FINO_REACTION
@anchor{#fino_reaction}
@quotation
Computes the reaction at the selected physical group.
@end quotation

@smallformat
@verbatim
FINO_REACTION PHYSICAL_GROUP <physical_group> [ { FORCE | MOMENT } ] [ {X0 | Y0 | Z0 } expr ] RESULT { <variable> | <vector> }
@end verbatim
@end smallformat

The result is stored in the variable or vector provided, depending on
the number of degrees of freedoms of the problem. If the object passed
as @code{RESULT} does not exist, an appropriate object (scalar variable
or vector) is created. For the elastic problem, the components of the
total reaction force are stored in the result vector. For the thermal
problem, the total power passing through the entity is computed as an
scalar.

@node FINO_SOLVER
@subsection FINO_SOLVER
@anchor{#fino_solver}
@quotation
Sets options related to the solver and the computation of gradients.
@end quotation

@smallformat
@verbatim
FINO_SOLVER [ PROGRESS ]
 [ PC { gamg | mumps | lu | hypre | sor | bjacobi | cholesky | ... } ]
 [ KSP { gmres | mumps | bcgs | bicg | richardson | chebyshev | ... } ]
 [ TS { bdf | arkimex | rosw | glle | beuler | ... } ]
 [ SNES_TYPE { newtonls | newtontr | nrichardson | ngmres | qn | ngs | ... } ]
 [ GRADIENT { gauss | nodes | none } ]
 [ GRADIENT_HIGHER { average | nodes } ]
 [ SMOOTH { always | never | material } ]
 [ ELEMENT_WEIGHT { volume_times_quality | volume | quality | flat } ]
@end verbatim
@end smallformat

If the keyword @code{PROGRESS} is given, three ASCII lines will show in
the terminal the progress of the ensamble of the stiffness matrix (or
matrices), the solution of the system of equations and the computation
of gradients (stresses). The preconditioner, linear and non-linear
solver might be any of those available in PETSc:

@itemize
@item
List of @code{PC}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html}.
@item
List of @code{KSP}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html}.
@item
List of @code{TS}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSType.html}.
@item
List of @code{SNES}s
@url{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESType.html}.
@end itemize

If either @code{PC} or @code{KSP} is set to @code{mumps} (and PETSc is
compiled with MUMPS support) then this direct solver is used. For the
mechanical problem, the default is to use GAMG as the preconditioner and
PETSc's default solver (GMRES). For the thermal problem, the default is
to use the default PETSc settings. For the modal problem, the default is
to use the default SLEPc settings. The @code{GRADIENT} keyword controls
how the derivatives (i.e.@ strains) at the first-order nodes are to be
computed out of the primary unknowns (i.e.@ displacements).

@itemize
@item
@code{gauss} (default) computes the derivatives at the gauss points and
the extrapolates the values to the nodes
@item
@code{nodes} computes the derivatives direcetly at the nodes
@item
@code{none} does not compute any derivative at all
@end itemize

The way derivatives are computed at high-order nodes (i.e.@ those at the
middle of edges or faces) is controlled with @code{GRADIENT_HIGHER}:

@itemize
@item
@code{average} (default) assigns the plain average of the first-order
nodes that surrond each high-order node
@item
@code{none} computes the derivatives at the location of the high-order
nodes
@end itemize

The keyword @code{SMOOTH} controls how the gradient-based functions
(i.e.@ strains, stresses, etc) are smoothed---or not---to obtain nodal
values out of data which primarily comes from element-wise evaluations
at the Gauss points.

@itemize
@item
@code{always} (default) computes a single value for each node by
averaging the contributions of individual elements.
@item
@code{never} keeps the contribution of each individual element separate.
This option implies that the output mesh is different from the input
mesh as each element now has a ``copy'' of the original shared nodes.
@item
@code{material} averages element contribution only for those elements
that belong to the same material (i.e.@ physical group). As with
@code{never}, a new output mesh is created where the nodes are
duplicated even for those elements which belong to the same physical
group.
@end itemize

The way individual contributions of different elements to the same node
are averaged is controlled by @code{ELEMENT_WEIGHT}:

@itemize
@item
@code{volume_times_quality} (default) weights each element by the
product of its volume times its quality
@item
@code{volume} weights each element by the its volume
@item
@code{quality} weights each element by the its quality
@item
@code{flat} performs plain averages (i.e.@ the same weight for all
elements)
@end itemize

@node FINO_STEP
@subsection FINO_STEP
@anchor{#fino_step}
@quotation
Ask Fino to solve the problem and advance one step.
@end quotation

@smallformat
@verbatim
FINO_STEP
@end verbatim
@end smallformat

The location of the @code{FINO_STEP} keyword within the input file marks
the logical location where the problem is solved and the result
functions (displacements, temperatures, stresses, etc.) are available
for output or further computation.

@node Mesh keywords
@section Mesh keywords
@anchor{#mesh-keywords}

@menu
* MATERIAL::
* MESH::
* MESH_FILL_VECTOR::
* MESH_FIND_MINMAX::
* MESH_INTEGRATE::
* MESH_MAIN::
* MESH_POST::
* PHYSICAL_GROUP::
* PHYSICAL_PROPERTY::
@end menu

@node MATERIAL
@subsection MATERIAL
@anchor{#material}
@quotation

@smallformat
@verbatim
MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1> [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1> <expr_1> [ <property_name_2> <expr_2> [ ... ] ] ]
@end verbatim
@end smallformat

@end quotation

@node MESH
@subsection MESH
@anchor{#mesh}
@quotation
Reads an unstructured mesh from an external file in MSH, VTK or FRD
format.
@end quotation

@smallformat
@verbatim
MESH [ NAME <name> ] { FILE <file_id> | FILE_PATH <file_path> } [ DIMENSIONS <num_expr> ]
 [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]
 [ INTEGRATION { full | reduced } ] [ RE_READ ]
 [ READ_SCALAR <name_in_mesh> AS <function_name> ] [...]
 [ READ_FUNCTION <function_name> ] [...]
@end verbatim
@end smallformat

If there will be only one mesh in the input file, the @code{NAME} is
optional. Yet it might be needed in cases where there are many meshes
and one needs to refer to a particular mesh, such as in @code{MESH_POST}
or @code{MESH_INTEGRATE}. When solving PDEs (such as in Fino or
milonga), the first mesh is the problem mesh. Either a file identifier
(defined previously with a @code{FILE} keyword) or a file path should be
given. The format is read from the extension, which should be either

@itemize
@item
@code{.msh}
@uref{http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format,Gmsh ASCII
format}, versions 2.2, 4.0 or 4.1
@item
@code{.vtk}
@uref{https://lorensen.github.io/VTKExamples/site/VTKFileFormats/,ASCII
legacy VTK}
@item
@code{.frd}
@uref{https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html,CalculiX's
FRD ASCII output})
@end itemize

Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides information about physical groups. The spatial
dimensions should be given with @code{DIMENSION}. If material properties
are uniform and given with variables, the dimensions are not needed and
will be read from the file. But if spatial functions are needed (either
for properties or read from the mesh file), an explicit value for the
mesh dimensions is needed. If either @code{SCALE} or @code{OFFSET} are
given, the node position if first shifted and then scaled by the
provided amounts. For each @code{READ_SCALAR} keyword, a point-wise
defined function of space named @code{<function_name>} is defined and
filled with the scalar data named @code{<name_in_mesh>} contained in the
mesh file. The @code{READ_FUNCTION} keyword is a shortcut when the
scalar name and the to-be-defined function are the same. If no
@code{NAME} is given, the first mesh to be defined is called
@code{first}.

@node MESH_FILL_VECTOR
@subsection MESH_FILL_VECTOR
@anchor{#mesh_fill_vector}
@quotation
Fills the elements of a vector with data evaluated at the nodes or the
cells of a mesh.
@end quotation

@smallformat
@verbatim
MESH_FILL_VECTOR VECTOR <vector> { FUNCTION <function> | EXPRESSION <expr> } 
 [ MESH <name> ] [ NODES | CELLS ]
@end verbatim
@end smallformat

The vector to be filled needs to be already defined and to have the
appropriate size, either the number of nodes or cells of the mesh
depending on @code{NODES} or @code{CELLS} (default is nodes). The
elements of the vectors will be either the @code{FUNCTION} or the
@code{EXPRESSION} of @math{x}, @math{y} and @math{z} evaluated at the
nodes or cells of the provided mesh. If there is more than one mesh, the
name has to be given.

@node MESH_FIND_MINMAX
@subsection MESH_FIND_MINMAX
@anchor{#mesh_find_minmax}
@quotation
Finds absolute extrema of a function or expression within a mesh-based
domain.
@end quotation

@smallformat
@verbatim
MESH_FIND_MINMAX { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <name> ] [ OVER <physical_group_name> ] [ NODES | CELLS ]
 [ MIN <variable> ] [ MAX <variable> ]
 [ X_MIN <variable> ] [ Y_MIN <variable> ] [ Z_MIN <variable> ] [ I_MIN <variable> ]
 [ X_MAX <variable> ] [ Y_MAX <variable> ] [ Z_MAX <variable> ] [ I_MAX <variable> ]
@end verbatim
@end smallformat

Either a @code{FUNCTION} or an @code{EXPRESSION} should be given. In the
first case, just the function name is expected (i.e.@ not its
arguments). In the second case, a full algebraic expression including
the arguments is expected. If no explicit mesh is provided, the main
mesh is used to search for the extrema. If the @code{OVER} keyword is
given, the search is performed only on the provided physical group.
Depending on the problem type, it might be needed to switch from
@code{NODES} to @code{CELLS} but this is usually not needed. If given,
the minimum (maximum) value is stored in the variable provided by the
@code{MIN} (@code{MAX}) keyword. If given, the @math{x} (or @math{y} or
@math{z}) coordinate of the minimum (maximum) value is stored in the
variable provided by the @code{X_MIN} (or @code{Y_MIN} or @code{Z_MIN})
(@code{X_MAX}, @code{Y_MAX}, @code{Z_MAX}) keyword. If given, the index
of the minimum (maximum) value (i.e.@ the node or cell number) is stored
in the variable provided by the @code{I_MIN} (@code{I_MAX}) keyword.

@node MESH_INTEGRATE
@subsection MESH_INTEGRATE
@anchor{#mesh_integrate}
@quotation
Performs a spatial integration of a function or expression over a mesh.
@end quotation

@smallformat
@verbatim
MESH_INTEGRATE { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <mesh_identifier> ] [ OVER <physical_group> ] [ NODES | CELLS ]
 RESULT <variable>
@end verbatim
@end smallformat

The integrand may be either a @code{FUNCTION} or an @code{EXPRESSION}.
In the first case, just the function name is expected (i.e.@ not its
arguments). In the second case, a full algebraic expression including
the arguments is expected. If the expression is just @code{1} then the
volume (or area or length) of the domain is computed. Note that
arguments ought to be @code{x}, @code{y} and/or @code{z}. If there are
more than one mesh defined, an explicit one has to be given with
@code{MESH}. By default the integration is performed over the
highest-dimensional elements of the mesh. If the integration is to be
carried out over just a physical group, it has to be given in
@code{OVER}. Either @code{NODES} or @code{CELLS} define how the
integration is to be performed. In the first case a the integration is
performed using the Gauss points and weights associated to each element
type. In the second case, the integral is computed as the sum of the
product of the function evaluated at the center of each cell (element)
and the cell's volume. The scalar result of the integration is stored in
the variable given by @code{RESULT}. If the variable does not exist, it
is created.

@node MESH_MAIN
@subsection MESH_MAIN
@anchor{#mesh_main}
@quotation

@smallformat
@verbatim
MESH_MAIN [ <name> ]
@end verbatim
@end smallformat

@end quotation

@node MESH_POST
@subsection MESH_POST
@anchor{#mesh_post}
@quotation

@smallformat
@verbatim
MESH_POST [ MESH <mesh_identifier> ] { FILE <name> | FILE_PATH <file_path> } [ NO_MESH ] [ FORMAT { gmsh | vtk } ] [ CELLS | ] NODES ] [ NO_PHYSICAL_NAMES ] [ VECTOR <function1_x> <function1_y> <function1_z> ] [...] [ <scalar_function_1> ] [ <scalar_function_2> ] ...
@end verbatim
@end smallformat

@end quotation

@node PHYSICAL_GROUP
@subsection PHYSICAL_GROUP
@anchor{#physical_group}
@quotation
Defines a physical group of elements within a mesh file.
@end quotation

@smallformat
@verbatim
PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ]
 [ MATERIAL <name> ]
 [ BC <bc_1> <bc_2> ... ]
@end verbatim
@end smallformat

A name is mandatory for each physical group defined within the input
file. If there is no physical group with the provided name in the mesh,
this instruction makes no effect. If there are many meshes, an explicit
mesh can be given with @code{MESH}. Otherwise, the physical group is
defined on the main mesh. An explicit dimension of the physical group
can be provided with @code{DIMENSION}. For volumetric elements, physical
groups can be linked to materials using @code{MATERIAL}. Note that if a
material is created with the same name as a physical group in the mesh,
they will be linked automatically. The @code{MATERIAL} keyword in
@code{PHYSICAL_GROUP} is used to link a physical group in a mesh file
and a material in the wasora input file with different names. For
non-volumetric elements, boundary conditions can be assigned by using
the @code{BC} keyword. This should be the last keyword of the line, and
any token afterwards is treated specially by the underlying solver
(i.e.@ Fino or milonga).

@node PHYSICAL_PROPERTY
@subsection PHYSICAL_PROPERTY
@anchor{#physical_property}
@quotation

@smallformat
@verbatim
PHYSICAL_PROPERTY <name> [ <material_name1> <expr1> [ <material_name2> <expr2> ] ... ]
@end verbatim
@end smallformat

@end quotation

@node Special input distributions
@section Special input distributions
@anchor{#special-input-distributions}
TBD.

@node Boundary conditions
@section Boundary conditions
@anchor{#boundary-conditions}
TBD.

@node Result functions
@section Result functions
@anchor{#result-functions}
TBD.

@node Wasora keywords
@section Wasora keywords
@anchor{#wasora-keywords}

@menu
* =::
* _=::
* ABORT::
* ALIAS::
* CALL::
* CLOSE::
* CONST::
* DEFAULT_ARGUMENT_VALUE::
* DIFFERENTIAL::
* DO_NOT_EVALUATE_AT_PARSE_TIME::
* FILE::
* FIT::
* FUNCTION::
* HISTORY::
* IF::
* IMPLICIT::
* INCLUDE::
* INITIAL_CONDITIONS_MODE::
* LOAD_PLUGIN::
* LOAD_ROUTINE::
* M4::
* MATRIX::
* MINIMIZE::
* PARAMETRIC::
* PHASE_SPACE::
* PRINT::
* PRINT_FUNCTION::
* PRINT_VECTOR::
* READ::
* SEMAPHORE::
* SHELL::
* SOLVE::
* TIME_PATH::
* VAR::
* VECTOR::
* VECTOR_SORT::
* WRITE::
@end menu

@node =
@subsection =
@anchor{#section}
@quotation
Assign an expression to a variable, a vector or a matrix.
@end quotation

@smallformat
@verbatim
<var>[ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <vector>(<expr_i>)[<expr_i_min, expr_i_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <matrix>(<expr_i>,<expr_j>)[<expr_i_min, expr_i_max; expr_j_min, expr_j_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr>
@end verbatim
@end smallformat

@node _=
@subsection _.=
@anchor{#section-1}
@quotation
Add an equation to the DAE system to be solved in the phase space
spanned by @code{PHASE_SPACE}.
@end quotation

@smallformat
@verbatim
{ 0[(i[,j]][<imin:imax[;jmin:jmax]>] | <expr1> } .= <expr2>
@end verbatim
@end smallformat

@node ABORT
@subsection ABORT
@anchor{#abort}
@quotation
Catastrophically abort the execution and quit wasora.
@end quotation

@smallformat
@verbatim
ABORT
@end verbatim
@end smallformat

Whenever the instruction @code{ABORT} is executed, wasora quits without
closing files or unlocking shared memory objects. The objective of this
instruction is, as illustrated in the examples, either to debug complex
input files and check the values of certain variables or to
conditionally abort the execution using @code{IF} clauses.

@node ALIAS
@subsection ALIAS
@anchor{#alias}
@quotation
Define a scalar alias of an already-defined indentifier.
@end quotation

@smallformat
@verbatim
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }
@end verbatim
@end smallformat

The existing object can be a variable, a vector element or a matrix
element. In the first case, the name of the variable should be given as
the existing object. In the second case, to alias the second element of
vector @code{v} to the new name @code{new}, @code{v(2)} should be given
as the existing object. In the third case, to alias second element (2,3)
of matrix @code{M} to the new name @code{new}, @code{M(2,3)} should be
given as the existing object.

@node CALL
@subsection CALL
@anchor{#call}
@quotation
Call a previously dynamically-loaded user-provided routine.
@end quotation

@smallformat
@verbatim
CALL <name> [ expr_1 expr_2 ... expr_n ]
@end verbatim
@end smallformat

@node CLOSE
@subsection CLOSE
@anchor{#close}
@quotation
Explicitly close an already-@code{OPEN}ed file.
@end quotation

@smallformat
@verbatim
CLOSE
@end verbatim
@end smallformat

@node CONST
@subsection CONST
@anchor{#const}
@quotation
Mark a scalar variable, vector or matrix as a constant.
@end quotation

@smallformat
@verbatim
CONST name_1 [ <name_2> ] ... [ <name_n> ]
@end verbatim
@end smallformat

@node DEFAULT_ARGUMENT_VALUE
@subsection DEFAULT_ARGUMENT_VALUE
@anchor{#default_argument_value}
@quotation
Give a default value for an optional commandline argument.
@end quotation

@smallformat
@verbatim
DEFAULT_ARGUMENT_VALUE <constant> <string>
@end verbatim
@end smallformat

If a @code{$n} construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.

@node DIFFERENTIAL
@subsection DIFFERENTIAL
@anchor{#differential}
@quotation
Explicitly mark variables, vectors or matrices as ``differential'' to
compute intial conditions of DAE systems.
@end quotation

@smallformat
@verbatim
DIFFERENTIAL { <var_1> <var_2> ... | <vector_1> <vector_2> ... | <matrix_1> <matrix_2> ... }
@end verbatim
@end smallformat

@node DO_NOT_EVALUATE_AT_PARSE_TIME
@subsection DO_NOT_EVALUATE_AT_PARSE_TIME
@anchor{#do_not_evaluate_at_parse_time}
@quotation
Ask wasora not to evaluate assignments at parse time.
@end quotation

@smallformat
@verbatim
DO_NOT_EVALUATE_AT_PARSE_TIME
@end verbatim
@end smallformat

@node FILE
@subsection FILE
@anchor{#file}
@quotation
Define a file, either as input or as output, for further usage.
@end quotation

@smallformat
@verbatim
< FILE | OUTPUT_FILE | INPUT_FILE > <name> <printf_format> [ expr_1 expr_2 ... expr_n ] [ INPUT | OUTPUT | MODE <fopen_mode> ] [ OPEN | DO_NOT_OPEN ]
@end verbatim
@end smallformat

@node FIT
@subsection FIT
@anchor{#fit}
@quotation
Fit a function of one or more arguments to a set of pointwise-defined
data.
@end quotation

@smallformat
@verbatim
FIT <function_to_be_fitted> TO <function_with_data> VIA <var_1> <var_2> ... <var_n>
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MIN <expr_1> <expr_2> ... <expr_j> ]
 [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]
 [ DELTAEPSREL <expr> ] [ DELTAEPSABS <expr> ] [ MAX_ITER <expr> ]
 [ VERBOSE ] [ RERUN | DO_NOT_RERUN ]
@end verbatim
@end smallformat

The function with the data has to be point-wise defined (i.e.@ a
@code{FUNCTION} read from a file with inline @code{DATA}). The function
to be fitted has to be parametrized with at least one of the variables
provided after the @code{VIA} keyword. Only the names of the functions
have to be given, not the arguments. Both functions have to have the
same number of arguments. The initial guess of the solution is given by
the initial value of the variables listed in the @code{VIA} keyword.
Analytical expressions for the gradient of the function to be fitted
with respect to the parameters to be fitted can be optionally given with
the @code{GRADIENT} keyword. If none is provided, the gradient will be
computed numerically using finite differences. A range over which the
residuals are to be minimized can be given with @code{RANGE_MIN} and
@code{RANGE_MAX}. The expressions give the range of the arguments of the
functions, not of the parameters. For multidimensional fits, the range
is an hypercube. If no range is given, all the definition points of the
function with the data are used for the fit. Convergence can be
controlled by giving the relative and absolute tolreances with
@code{DELTAEPSREL} (default @code{1e-4}) and @code{DELTAEPSABS} (default
@code{1e-6}), and with the maximum number of iterations @code{MAX_ITER}
(default 100). If the optional keyword @code{VERBOSE} is given, some
data of the intermediate steps is written in the standard output. The
combination of arguments that minimize the function are computed and
stored in the variables. So if @code{f(x,y)} is to be minimized, after a
@code{MINIMIZE f} both @code{x} and @code{y} would have the appropriate
values. The details of the method used can be found in
@uref{https://www.gnu.org/software/gsl/doc/html/multimin.html,GSL's
documentation}. Some of them use derivatives and some of them do not.
Default method is @code{gsl_multimin_fminimizer_nmsimplex2}, which does
not need derivatives.

@node FUNCTION
@subsection FUNCTION
@anchor{#function}
@quotation
Define a function of one or more variables.
@end quotation

@smallformat
@verbatim
FUNCTION <name>(<var_1>[,var2,...,var_n]) { [ = <expr> | FILE_PATH <file_path> | ROUTINE <name> | | MESH <name> { DATA <new_vector_name> | VECTOR <existing_vector_name> } { NODES | CELLS } | [ VECTOR_DATA <vector_1> <vector_2> ... <vector_n> <vector_n+1> ] } [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ] [ SIZES <expr_1> <expr_2> ... <expr_n> ] [ X_INCREASES_FIRST <expr> ] [ DATA <num_1> <num_2> ... <num_N> ]
@end verbatim
@end smallformat

The number of variables @math{n} is given by the number of arguments
given between parenthesis after the function name. The arguments are
defined as new variables if they had not been already defined as
variables. If the function is given as an algebraic expression, the
short-hand operator @code{:=} can be used. That is to say,
@code{FUNCTION f(x) = x^2} is equivalent to @code{f(x) := x^2}. If a
@code{FILE_PATH} is given, an ASCII file containing at least @math{n+1}
columns is expected. By default, the first @math{n} columns are the
values of the arguments and the last column is the value of the function
at those points. The order of the columns can be changed with the
keyword @code{COLUMNS}, which expects @math{n+1} expressions
corresponding to the column numbers. A function of type @code{ROUTINE}
calls an already-defined user-provided routine using the @code{CALL}
keyword and passes the values of the variables in each required
evaluation as a @code{double *} argument. If @code{MESH} is given, the
definition points are the nodes or the cells of the mesh. The function
arguments should be @math{(x)}, @math{(x,y)} or @math{(x,y,z)} matching
the dimension the mesh. If the keyword @code{DATA} is used, a new empty
vector of the appropriate size is defined. The elements of this new
vector can be assigned to the values of the function at the @math{i}-th
node or cell. If the keyword @code{VECTOR} is used, the values of the
dependent variable are taken to be the values of the already-existing
vector. Note that this vector should have the size of the number of
nodes or cells the mesh has, depending on whether @code{NODES} or
@code{CELLS} is given. If @code{VECTOR_DATA} is given, a set of
@math{n+1} vectors of the same size is expected. The first @math{n+1}
correspond to the arguments and the last one is the function value.
Interpolation schemes can be given for either one or multi-dimensional
functions with @code{INTERPOLATION}. Available schemes for @math{n=1}
are:

@itemize
@item
linear
@item
polynomial, the grade is equal to the number of data minus one
@item
spline, cubic (needs at least 3 points)
@item
spline_periodic
@item
akima (needs at least 5 points)
@item
akima_periodic (needs at least 5 points)
@item
steffen, always-monotonic splines-like (available only with GSL >= 2.0)
@end itemize

Default interpolation scheme for one-dimensional functions is
@code{(*gsl_interp_linear)}.

Available schemes for @math{n>1} are:

@itemize
@item
nearest, @math{f(\vec{x})} is equal to the value of the closest
definition point
@item
shepard,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting,inverse
distance weighted average definition points} (might lead to inefficient
evaluation)
@item
shepard_kd,
@uref{https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method,average
of definition points within a kd-tree} (more efficient evaluation
provided @code{SHEPARD_RADIUS} is set to a proper value)
@item
bilinear, only available if the definition points configure an
structured hypercube-like grid. If @math{n>3}, @code{SIZES} should be
given.
@end itemize

For @math{n>1}, if the euclidean distance between the arguments and the
definition points is smaller than @code{INTERPOLATION_THRESHOLD}, the
definition point is returned and no interpolation is performed. Default
value is square root of @code{9.5367431640625e-07}. The initial radius
of points to take into account in @code{shepard_kd} is given by
@code{SHEPARD_RADIUS}. If no points are found, the radius is double
until at least one definition point is found. The radius is doubled
until at least one point is found. Default is @code{1.0}. The exponent
of the @code{shepard} method is given by @code{SHEPARD_EXPONENT}.
Default is @code{2}. When requesting @code{bilinear} interpolation for
@math{n>3}, the number of definition points for each argument variable
has to be given with @code{SIZES}, and wether the definition data is
sorted with the first argument changing first (@code{X_INCREASES_FIRST}
evaluating to non-zero) or with the last argument changing first (zero).
The function can be pointwise-defined inline in the input using
@code{DATA}. This should be the last keyword of the line, followed by
@math{N=k\cdot (n+1)} expresions giving @math{k} definition points:
@math{n} arguments and the value of the function. Multiline continuation
using brackets @code{@{} and @code{@}} can be used for a clean data
organization. See the examples.

@node HISTORY
@subsection HISTORY
@anchor{#history}
@quotation
Record the time history of a variable as a function of time.
@end quotation

@smallformat
@verbatim
HISTORY <variable> <function>
@end verbatim
@end smallformat

@node IF
@subsection IF
@anchor{#if}
@quotation
Begin a conditional block.
@end quotation

@smallformat
@verbatim
IF expr
<block_of_instructions_if_expr_is_true>
[ ELSE ]
[block_of_instructions_if_expr_is_false]
ENDIF
@end verbatim
@end smallformat

@node IMPLICIT
@subsection IMPLICIT
@anchor{#implicit}
@quotation
Define whether implicit declaration of variables is allowed or not.
@end quotation

@smallformat
@verbatim
IMPLICIT { NONE | ALLOWED }
@end verbatim
@end smallformat

By default, wasora allows variables (but not vectors nor matrices) to be
implicitly declared. To avoid introducing errors due to typos, explicit
declaration of variables can be forced by giving @code{IMPLICIT NONE}.
Whether implicit declaration is allowed or explicit declaration is
required depends on the last @code{IMPLICIT} keyword given, which by
default is @code{ALLOWED}.

@node INCLUDE
@subsection INCLUDE
@anchor{#include}
@quotation
Include another wasora input file.
@end quotation

@smallformat
@verbatim
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]
@end verbatim
@end smallformat

Includes the input file located in the string @code{file_path} at the
current location. The effect is the same as copying and pasting the
contents of the included file at the location of the @code{INCLUDE}
keyword. The path can be relative or absolute. Note, however, that when
including files inside @code{IF} blocks that instructions are
conditionally-executed but all definitions (such as function
definitions) are processed at parse-time independently from the
evaluation of the conditional. The optional @code{FROM} and @code{TO}
keywords can be used to include only portions of a file.

@node INITIAL_CONDITIONS_MODE
@subsection INITIAL_CONDITIONS_MODE
@anchor{#initial_conditions_mode}
@quotation
Define how initial conditions of DAE problems are computed.
@end quotation

@smallformat
@verbatim
INITIAL_CONDITIONS_MODE { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }
@end verbatim
@end smallformat

In DAE problems, initial conditions may be either:

@itemize
@item
equal to the provided expressions (@code{AS_PROVIDED})
@item
the derivatives computed from the provided phase-space variables
(@code{FROM_VARIABLES})
@item
the phase-space variables computed from the provided derivatives
(@code{FROM_DERIVATIVES})
@end itemize

In the first case, it is up to the user to fulfill the DAE system
at@ @math{t = 0}. If the residuals are not small enough, a convergence
error will occur. The @code{FROM_VARIABLES} option means calling IDA's
@code{IDACalcIC} routine with the parameter @code{IDA_YA_YDP_INIT}. The
@code{FROM_DERIVATIVES} option means calling IDA's @code{IDACalcIC}
routine with the parameter IDA_Y_INIT. Wasora should be able to
automatically detect which variables in phase-space are differential and
which are purely algebraic. However, the @code{DIFFERENTIAL} keyword may
be used to explicitly define them. See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.

@node LOAD_PLUGIN
@subsection LOAD_PLUGIN
@anchor{#load_plugin}
@quotation
Load a wasora plug-in from a dynamic shared object.
@end quotation

@smallformat
@verbatim
LOAD_PLUGIN { <file_path> | <plugin_name> }
@end verbatim
@end smallformat

A wasora plugin in the form of a dynamic shared object
(i.e.@ @code{.so}) can be loaded either with the @code{LOAD_PLUGIN}
keyword or from the command line with the @code{-p} option. Either a
file path or a plugin name can be given. The following locations are
tried:

@itemize
@item
the current directory @code{./}
@item
the parent directory @code{../}
@item
the user's @code{LD_LIBRARY_PATH}
@item
the cache file @code{/etc/ld.so.cache}
@item
the directories @code{/lib}, @code{/usr/lib}, @code{/usr/local/lib}
@end itemize

If a wasora plugin was compiled and installed following the
@code{make install} procedure, the plugin should be loaded by just
passing the name to @code{LOAD_PLUGIN}.

@node LOAD_ROUTINE
@subsection LOAD_ROUTINE
@anchor{#load_routine}
@quotation
Load one or more routines from a dynamic shared object.
@end quotation

@smallformat
@verbatim
LOAD_ROUTINE <file_path> <routine_1> [ <routine_2> ... <routine_n> ]
@end verbatim
@end smallformat

@node M4
@subsection M4
@anchor{#m4}
@quotation
Call the @code{m4} macro processor with definitions from wasora
variables or expressions.
@end quotation

@smallformat
@verbatim
M4 { INPUT_FILE <file_id> | FILE_PATH <file_path> } { OUTPUT_FILE <file_id> | OUTPUT_FILE_PATH <file_path> } [ EXPAND <name> ] ... } [ MACRO <name> [ <format> ] <definition> ] ... }
@end verbatim
@end smallformat

@node MATRIX
@subsection MATRIX
@anchor{#matrix}
@quotation
Define a matrix.
@end quotation

@smallformat
@verbatim
MATRIX <name> ROWS <expr> COLS <expr> [ DATA num_expr_1 num_expr_2 ... num_expr_n ]
@end verbatim
@end smallformat

@node MINIMIZE
@subsection MINIMIZE
@anchor{#minimize}
@quotation
Find the combination of arguments that give a (relative) minimum of a
function.
@end quotation

@smallformat
@verbatim
MINIMIZE <function>
 [ METHOD { nmsimplex2 | nmsimplex | nmsimplex2rand | conjugate_fr | conjugate_pr | vector_bfgs2 | vector_bfgs | steepest_descent}
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ GUESS <expr_1> <expr_2> ... <expr_n> ]
 [ MIN <expr_1> <expr_2> ... <expr_n> ]
 [ MAX <expr_1> <expr_2> ... <expr_n> ]
 [ STEP <expr_1> <expr_2> ... <expr_n> ]
 [ MAX_ITER <expr> ] [ TOL <expr> ] [ GRADTOL <expr> ]
 [ VERBOSE ] [ NORERUN ]
@end verbatim
@end smallformat

@node PARAMETRIC
@subsection PARAMETRIC
@anchor{#parametric}
@quotation
Systematically sweep a zone of the parameter space, i.e.@ perform a
parametric run.
@end quotation

@smallformat
@verbatim
PARAMETRIC <var_1> [ ... <var_n> ] [ TYPE { linear | logarithmic | random | gaussianrandom | sobol | niederreiter | halton | reversehalton } ] [ MIN <num_expr_1> ... <num_expr_n> ] [ MAX <num_expr_1> ... <num_expr_n> ] [ STEP <num_expr_1> ... <num_expr_n> ] [ NSTEPS <num_expr_1> ... <num_expr_n> ] [ OUTER_STEPS <num_expr> ] [ MAX_DAUGHTERS <num_expr> ] [ OFFSET <num_expr> ] [ ADIABATIC ]
@end verbatim
@end smallformat

@node PHASE_SPACE
@subsection PHASE_SPACE
@anchor{#phase_space}
@quotation
Define which variables, vectors and/or matrices belong to the phase
space of the DAE system to be solved.
@end quotation

@smallformat
@verbatim
PHASE_SPACE { <vars> | <vectors> | <matrices> }
@end verbatim
@end smallformat

@node PRINT
@subsection PRINT
@anchor{#print}
@quotation
Print plain-text and/or formatted data to the standard output or into an
output file.
@end quotation

@smallformat
@verbatim
PRINT [ FILE <file_id> | FILE_PATH <file_path> ] [ NONEWLINE ] [ SEP <string> ] [ NOSEP ] [ HEADER ] [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ]
@end verbatim
@end smallformat

Each argument @code{object} that is not a keyword is expected to be part
of the output, can be either a matrix, a vector, an scalar algebraic
expression. If the given object cannot be solved into a valid matrix,
vector or expression, it is treated as a string literal if
@code{IMPLICIT} is @code{ALLOWED}, otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
@code{TEXT} keyword. Hashes @code{#} appearing literal in text strings
have to be quoted to prevent the parser to treat them as comments within
the wasora input file and thus ignoring the rest of the line. Whenever
an argument starts with a porcentage sign @code{%}, it is treated as a C
@code{printf}-compatible format definition and all the objects that
follow it are printed using the given format until a new format
definition is found. The objects are treated as double-precision
floating point numbers, so only floating point formats should be given.
The default format is @code{"%g"}. Matrices, vectors, scalar
expressions, format modifiers and string literals can be given in any
desired order, and are processed from left to right. Vectors are printed
element-by-element in a single row. See @code{PRINT_VECTOR} to print
vectors column-wise. Matrices are printed element-by-element in a single
line using row-major ordering if mixed with other objects but in the
natural row and column fashion if it is the only given object. If the
@code{FILE} keyword is not provided, default is to write to stdout. If
the @code{NONEWLINE} keyword is not provided, default is to write a
newline @code{\n} character after all the objects are processed. The
@code{SEP} keywords expects a string used to separate printed objects,
the default is a tab `DEFAULT_PRINT_SEPARATOR' character. Use the
@code{NOSEP} keyword to define an empty string as object separator. If
the @code{HEADER} keyword is given, a single line containing the literal
text given for each object is printed at the very first time the
@code{PRINT} instruction is processed, starting with a hash @code{#}
character. If the @code{SKIP_STEP} (@code{SKIP_STATIC_STEP})keyword is
given, the instruction is processed only every the number of transient
(static) steps that results in evaluating the expression, which may not
be constant. By default the @code{PRINT} instruction is evaluated every
step. The @code{SKIP_HEADER_STEP} keyword works similarly for the
optional @code{HEADER} but by default it is only printed once. The
@code{SKIP_TIME} keyword use time advancements to choose how to skip
printing and may be useful for non-constant time-step problems.

@node PRINT_FUNCTION
@subsection PRINT_FUNCTION
@anchor{#print_function}
@quotation
Print one or more functions as a table of values of dependent and
independent variables.
@end quotation

@smallformat
@verbatim
PRINT_FUNCTION <function_1> [ { function_2 | expr_1 } ... { function_n | expr_n-1 } ] [ FILE <file_id> | FILE_PATH <file_path> ] [ HEADER ] [ MIN <expr_1> <expr_2> ... <expr_m> ] [ MAX <expr_1> <expr_2> ... <expr_m> ] [ STEP <expr_1> <expr_2> ... <expr_m> ] [ NSTEPs <expr_1> <expr_2> ... <expr_m> ] [ FORMAT <print_format> ] [ PHYSICAL_ENTITY <name> ]
@end verbatim
@end smallformat

@node PRINT_VECTOR
@subsection PRINT_VECTOR
@anchor{#print_vector}
@quotation
Print the elements of one or more vectors.
@end quotation

@smallformat
@verbatim
PRINT_VECTOR [ FILE <file_id> ] FILE_PATH <file_path> ] [ { VERTICAL | HORIZONTAL } ] [ ELEMS_PER_LINE <expr> ] [ FORMAT <print_format> ] <vector_1> [ vector_2 ... vector_n ]
@end verbatim
@end smallformat

@node READ
@subsection READ
@anchor{#read}
@quotation
Read data (variables, vectors o matrices) from files or shared-memory
segments.
@end quotation

@smallformat
@verbatim
[ READ | WRITE ] [ SHM <name> ] [ { ASCII_FILE_PATH | BINARY_FILE_PATH } <file_path> ] [ { ASCII_FILE | BINARY_FILE } <identifier> ] [ IGNORE_NULL ] [ object_1 object_2 ... object_n ]
@end verbatim
@end smallformat

@node SEMAPHORE
@subsection SEMAPHORE
@anchor{#semaphore}
@quotation
Perform either a wait or a post operation on a named shared semaphore.
@end quotation

@smallformat
@verbatim
[ SEMAPHORE | SEM ] <name> { WAIT | POST }
@end verbatim
@end smallformat

@node SHELL
@subsection SHELL
@anchor{#shell}
@quotation
Execute a shell command.
@end quotation

@smallformat
@verbatim
SHELL <print_format> [ expr_1 expr_2 ... expr_n ]
@end verbatim
@end smallformat

@node SOLVE
@subsection SOLVE
@anchor{#solve}
@quotation
Solve a non-linear system of@ @math{n} equations with@ @math{n}
unknowns.
@end quotation

@smallformat
@verbatim
SOLVE <n> UNKNOWNS <var_1> <var_2> ... <var_n> RESIDUALS <expr_1> <expr_2> ... <expr_n> ] GUESS <expr_1> <expr_2> ... <expr_n> ] [ METHOD { dnewton | hybrid | hybrids | broyden } ] [ EPSABS <expr> ] [ EPSREL <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ]
@end verbatim
@end smallformat

@node TIME_PATH
@subsection TIME_PATH
@anchor{#time_path}
@quotation
Force transient problems to pass through specific instants of time.
@end quotation

@smallformat
@verbatim
TIME_PATH <expr_1> [ <expr_2> [ ... <expr_n> ] ]
@end verbatim
@end smallformat

The time step @code{dt} will be reduced whenever the distance between
the current time @code{t} and the next expression in the list is greater
than @code{dt} so as to force @code{t} to coincide with the expressions
given. The list of expresssions should evaluate to a sorted list of
values.

@node VAR
@subsection VAR
@anchor{#var}
@quotation
Define one or more scalar variables.
@end quotation

@smallformat
@verbatim
VAR <name_1> [ <name_2> ] ... [ <name_n> ]
@end verbatim
@end smallformat

@node VECTOR
@subsection VECTOR
@anchor{#vector}
@quotation
Define a vector.
@end quotation

@smallformat
@verbatim
VECTOR <name> SIZE <expr> [ DATA <expr_1> <expr_2> ... <expr_n> | FUNCTION_DATA <function> ]
@end verbatim
@end smallformat

@node VECTOR_SORT
@subsection VECTOR_SORT
@anchor{#vector_sort}
@quotation
Sort the elements of a vector using a specific numerical order,
potentially making the same rearrangement of another vector.
@end quotation

@smallformat
@verbatim
VECTOR_SORT <vector> [ ASCENDING_ORDER | DESCENDING_ORDER ] [ <vector> ]
@end verbatim
@end smallformat

@node WRITE
@subsection WRITE
@anchor{#write}
@quotation
Write data (variables, vectors o matrices) to files or shared-memory
segments. See the @code{READ} keyword for usage details.
@end quotation

@node Fino variables
@section Fino variables
@anchor{#fino-variables}

@menu
* delta_sigma_max::
* displ_max::
* displ_max_x::
* displ_max_y::
* displ_max_z::
* fino_abstol::
* fino_divtol::
* fino_gamg_threshold::
* fino_iterations::
* fino_max_iterations::
* fino_penalty_weight::
* fino_reltol::
* fino_residual_norm::
* lambda::
* memory::
* memory_available::
* memory_petsc::
* nodes_rough::
* petsc_flops::
* sigma_max::
* sigma_max_x::
* sigma_max_y::
* sigma_max_z::
* strain_energy::
* time_cpu_build::
* time_cpu_solve::
* time_cpu_stress::
* time_petsc_build::
* time_petsc_solve::
* time_petsc_stress::
* time_wall_build::
* time_wall_solve::
* time_wall_stress::
* time_wall_total::
* T_max::
* T_min::
* u_at_displ_max::
* u_at_sigma_max::
* v_at_displ_max::
* v_at_sigma_max::
* w_at_displ_max::
* w_at_sigma_max::
@end menu

@node delta_sigma_max
@subsection delta_sigma_max
@anchor{#delta_sigma_max}
@quotation
@end quotation
The uncertainty of the maximum Von@ Mises stress@ @math{\sigma} of the
elastic problem. Not to be confused with the maximum uncertainty of the
Von@ Mises stress.

@node displ_max
@subsection displ_max
@anchor{#displ_max}
@quotation
@end quotation
The module of the maximum displacement of the elastic problem.

@node displ_max_x
@subsection displ_max_x
@anchor{#displ_max_x}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum displacement of the elastic
problem.

@node displ_max_y
@subsection displ_max_y
@anchor{#displ_max_y}
@quotation
@end quotation
The@ @math{y} coordinate of the maximum displacement of the elastic
problem.

@node displ_max_z
@subsection displ_max_z
@anchor{#displ_max_z}
@quotation
@end quotation
The@ @math{z} coordinate of the maximum displacement of the elastic
problem.

@node fino_abstol
@subsection fino_abstol
@anchor{#fino_abstol}
@quotation
@end quotation
Absolute tolerance of the linear solver, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e-50}.

@node fino_divtol
@subsection fino_divtol
@anchor{#fino_divtol}
@quotation
@end quotation
Divergence tolerance, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e+4}.

@node fino_gamg_threshold
@subsection fino_gamg_threshold
@anchor{#fino_gamg_threshold}
@quotation
@end quotation
Relative threshold to use for dropping edges in aggregation graph for
the [Geometric Algebraic Multigrid Preconditioner](http: as passed to
PETSc's [@code{PCGAMGSetThreshold}](http: A value of 0.0 means keep all
nonzero entries in the graph; negative means keep even zero entries in
the graph. Default @code{0.01}.

@node fino_iterations
@subsection fino_iterations
@anchor{#fino_iterations}
@quotation
@end quotation
This variable contains the actual number of iterations used by the
solver. It is set after @code{FINO_STEP}.

@node fino_max_iterations
@subsection fino_max_iterations
@anchor{#fino_max_iterations}
@quotation
@end quotation
Number of maximum iterations before diverging, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{10000}.

@node fino_penalty_weight
@subsection fino_penalty_weight
@anchor{#fino_penalty_weight}
@quotation
@end quotation
The weight @math{w} used when setting multi-freedom boundary conditions.
Higher values mean better precision in the constrain but distort the
matrix condition number. Default is @code{1e8}.

@node fino_reltol
@subsection fino_reltol
@anchor{#fino_reltol}
@quotation
@end quotation
Relative tolerance of the linear solver, as passed to PETSc's
[@code{KSPSetTolerances}](http: Default @code{1e-6}.

@node fino_residual_norm
@subsection fino_residual_norm
@anchor{#fino_residual_norm}
@quotation
@end quotation
This variable contains the residual obtained by the solver. It is set
after @code{FINO_STEP}.

@node lambda
@subsection lambda
@anchor{#lambda}
@quotation
@end quotation
Requested eigenvalue. It is equal to 1.0 until @code{FINO_STEP} is
executed.

@node memory
@subsection memory
@anchor{#memory}
@quotation
@end quotation
Maximum resident set size (global memory used), in bytes.

@node memory_available
@subsection memory_available
@anchor{#memory_available}
@quotation
@end quotation
Total available memory, in bytes.

@node memory_petsc
@subsection memory_petsc
@anchor{#memory_petsc}
@quotation
@end quotation
Maximum resident set size (memory used by PETSc), in bytes.

@node nodes_rough
@subsection nodes_rough
@anchor{#nodes_rough}
@quotation
@end quotation
The number of nodes of the mesh in @code{ROUGH} mode.

@node petsc_flops
@subsection petsc_flops
@anchor{#petsc_flops}
@quotation
@end quotation
Number of floating point operations performed by PETSc/SLEPc.

@node sigma_max
@subsection sigma_max
@anchor{#sigma_max}
@quotation
@end quotation
The maximum von Mises stress@ @math{\sigma} of the elastic problem.

@node sigma_max_x
@subsection sigma_max_x
@anchor{#sigma_max_x}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node sigma_max_y
@subsection sigma_max_y
@anchor{#sigma_max_y}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node sigma_max_z
@subsection sigma_max_z
@anchor{#sigma_max_z}
@quotation
@end quotation
The@ @math{x} coordinate of the maximum von Mises stress@ @math{\sigma}
of the elastic problem.

@node strain_energy
@subsection strain_energy
@anchor{#strain_energy}
@quotation
@end quotation
The strain energy stored in the solid, computed as
@math{1/2 \cdot \vec{u}^T K \vec{u}} where @math{\vec{u}} is the
displacements vector and @math{K} is the stiffness matrix.

@node time_cpu_build
@subsection time_cpu_build
@anchor{#time_cpu_build}
@quotation
@end quotation
CPU time insumed to build the problem matrices, in seconds.

@node time_cpu_solve
@subsection time_cpu_solve
@anchor{#time_cpu_solve}
@quotation
@end quotation
CPU time insumed to solve the problem, in seconds.

@node time_cpu_stress
@subsection time_cpu_stress
@anchor{#time_cpu_stress}
@quotation
@end quotation
CPU time insumed to compute the stresses from the displacements, in
seconds.

@node time_petsc_build
@subsection time_petsc_build
@anchor{#time_petsc_build}
@quotation
@end quotation
CPU time insumed by PETSc to build the problem matrices, in seconds.

@node time_petsc_solve
@subsection time_petsc_solve
@anchor{#time_petsc_solve}
@quotation
@end quotation
CPU time insumed by PETSc to solve the eigen-problem, in seconds.

@node time_petsc_stress
@subsection time_petsc_stress
@anchor{#time_petsc_stress}
@quotation
@end quotation
CPU time insumed by PETSc to compute the stresses, in seconds.

@node time_wall_build
@subsection time_wall_build
@anchor{#time_wall_build}
@quotation
@end quotation
Wall time insumed to build the problem matrices, in seconds.

@node time_wall_solve
@subsection time_wall_solve
@anchor{#time_wall_solve}
@quotation
@end quotation
Wall time insumed to solve the problem, in seconds.

@node time_wall_stress
@subsection time_wall_stress
@anchor{#time_wall_stress}
@quotation
@end quotation
Wall time insumed to compute the stresses, in seconds.

@node time_wall_total
@subsection time_wall_total
@anchor{#time_wall_total}
@quotation
@end quotation
Wall time insumed to initialize, build and solve, in seconds. CPU time
insumed to initialize, build and solve, in seconds. CPU time insumed by
PETSc to initialize, build and solve, in seconds.

@node T_max
@subsection T_max
@anchor{#t_max}
@quotation
@end quotation
The maximum temperature@ @math{T_\r{max}} of the thermal problem.

@node T_min
@subsection T_min
@anchor{#t_min}
@quotation
@end quotation
The minimum temperature@ @math{T_\r{min}} of the thermal problem.

@node u_at_displ_max
@subsection u_at_displ_max
@anchor{#u_at_displ_max}
@quotation
@end quotation
The@ @math{x} component@ @math{u} of the maximum displacement of the
elastic problem.

@node u_at_sigma_max
@subsection u_at_sigma_max
@anchor{#u_at_sigma_max}
@quotation
@end quotation
The@ @math{x} component@ @math{u} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@node v_at_displ_max
@subsection v_at_displ_max
@anchor{#v_at_displ_max}
@quotation
@end quotation
The@ @math{y} component@ @math{v} of the maximum displacement of the
elastic problem.

@node v_at_sigma_max
@subsection v_at_sigma_max
@anchor{#v_at_sigma_max}
@quotation
@end quotation
The@ @math{y} component@ @math{v} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@node w_at_displ_max
@subsection w_at_displ_max
@anchor{#w_at_displ_max}
@quotation
@end quotation
The@ @math{z} component@ @math{w} of the maximum displacement of the
elastic problem.

@node w_at_sigma_max
@subsection w_at_sigma_max
@anchor{#w_at_sigma_max}
@quotation
@end quotation
The@ @math{z} component@ @math{w} of the displacement where the maximum
von Mises stress@ @math{\sigma} of the elastic problem is located.

@bye
