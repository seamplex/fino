.\" Automatically generated by Pandoc 2.9.2
.\"
.TH "FINO" "1" "" "Fino User Manual" ""
.hy
.SH NAME
.PP
fino - a free finite-element thermo-mechanical solver
.SH SYNOPSIS
.PP
fino [\f[I]options\f[R]] input-file
[\f[I]optional_extra_arguments\f[R]]\&...
.SH DESCRIPTION
.PP
Fino is a free and open source tool released under the terms of the
GPLv3+ that uses the finite-element method to solve
.IP \[bu] 2
steady or quasistatic thermo-mechanical problems, or
.IP \[bu] 2
steady or transient heat conduction problems, or
.IP \[bu] 2
modal analysis problems.
.PP
Fino reads a plain-text input file which contains the problem definition
and a reference to a Gmsh(1) mesh file and it writes 100%-user defined
results in ASCII (through \f[C]PRINT\f[R] instructions within the input
file) and/or post-processing views in either \f[C].msh\f[R] or
\f[C].vtk\f[R] formats.
.SH EXAMPLES
.SS Minimum working example
.PP
The following is a MWE input file for Fino that reads a Gmsh-generated
\f[C].msh\f[R] file, solves a linear elastic problem and wriets the
results in a \f[C].vtk\f[R] file which can be post-processed by
Paraview:
.IP
.nf
\f[C]
MESH FILE_PATH tensile-test.msh  # mesh file in Gmsh format

E = 200e3   # [ MPa ] Young modulus \[ti] 200 GPa
nu = 0.3    # Poisson ratio

# boundary conditions (\[dq]left\[dq] and \[dq]right\[dq] come from the names in the mesh)
PHYSICAL_GROUP left  BC fixed
PHYSICAL_GROUP right BC Fx=1e4      # [ N ] load in x+

FINO_STEP   # solve

# write results (Von Mises, principal and displacements) in a VTK file
MESH_POST FILE_PATH tensile-mwe.vtk sigma sigma1 sigma2 sigma3 VECTOR u v w
\f[R]
.fi
.PP
The \f[C].geo\f[R] file that generates the mesh with Gmsh and the CAD
file in \f[C].step\f[R] format can be found in the \f[C]examples\f[R]
directory.
.SS Extended annotated example
.PP
The example above can be extended to give more information as the
following annotated input shows:
.IP
.nf
\f[C]
# tensile test example for Fino, see https://caeplex.com/p/41dd1
MESH FILE_PATH tensile-test.msh  # mesh file in Gmsh format (either version 2.2 or 4.x)

# uniform properties given as scalar variables
E = 200e3   # [ MPa ] Young modulus = 200 GPa
nu = 0.3    # Poisson\[cq]s ratio

# boundary conditions (\[dq]left\[dq] and \[dq]right\[dq] come from the names in the mesh)
PHYSICAL_GROUP left  BC fixed       # fixed end
PHYSICAL_GROUP right BC Fx=1e4      # [ N ] load in x+

FINO_SOLVER PROGRESS_ASCII  # print ascii progress bars (optional) 
# FINO_SOLVER KSP mumps       # try to use mumps (if it is not available gamg+gmres is used)
FINO_STEP                   # solve

# compute reaction force at fixed end
FINO_REACTION PHYSICAL_GROUP left RESULT R

# write results (Von Mises, principal and displacements) in a VTK file
MESH_POST FILE_PATH tensile-test.vtk delta_sigma sigma sigma1 sigma2 sigma3 VECTOR u v w

# print some results (otherwise output will be null)
PRINT SEP \[dq] \[dq] \[dq]displ_max =\[dq] %.3f displ_max \[dq]mm\[dq]
PRINT SEP \[dq] \[dq] \[dq]sigma_max = (\[dq] %.1f sigma_max \[dq]\[t+-]\[dq] delta_sigma_max \[dq]) MPa\[dq]
PRINT SEP \[dq] \[dq] \[dq]principal1 at center = (\[dq] %.5f sigma1(0,0,0) \[dq]\[t+-]\[dq] delta_sigma(0,0,0) \[dq]) MPa\[dq]
PRINT SEP \[dq] \[dq] \[dq]reaction  = [\[dq] %.3e R \[dq]] Newtons\[dq]
PRINT FILE_PATH tensile-sigma.dat %.0f sigma(0,0,0)
\f[R]
.fi
.SH OPTIONS
.TP
\f[B]\f[CB]-d\f[B]\f[R] or \f[B]\f[CB]--debug\f[B]\f[R]
Start in debug mode
.TP
\f[B]\f[CB]--node-debug\f[B]\f[R]
Ignore standard input, avoid debug mode
.TP
\f[B]\f[CB]-l\f[B]\f[R] or \f[B]\f[CB]--list\f[B]\f[R]
List defined symbols and exit
.TP
\f[B]\f[CB]-h\f[B]\f[R] or \f[B]\f[CB]--help\f[B]\f[R]
Display this help and exit
.TP
\f[B]\f[CB]-i\f[B]\f[R] or \f[B]\f[CB]--info\f[B]\f[R]
Display detailed code information and exit
.TP
\f[B]\f[CB]-v\f[B]\f[R] or \f[B]\f[CB]--version\f[B]\f[R]
Display version information and exit
.TP
\f[B]\f[CB]--mumps\f[B]\f[R]
use the MUMPS direct solver (if available)
.TP
\f[B]\f[CB]--progress\f[B]\f[R]
print ASCII progress bars for build, step and stress steps
.TP
\f[B]\f[CB]--petsc <option[=argument]>\f[B]\f[R]
Pass \f[C]-option argument\f[R] directly to PETSc/SLEPc, e.g.
.RS
.IP
.nf
\f[C]
$ fino tensile-test.fin --petsc ksp_view
\f[R]
.fi
.PP
The option \f[C]--petsc\f[R] is provided to avoid clashes with
PETSc\[cq] non-POSIX arguments.
Note that options are passed directly to PETSc/SLEPc if they do not
clash with Fino/wasora.
The same command as above could have been called as
.IP
.nf
\f[C]
$ fino tensile-test.fin -ksp_view
\f[R]
.fi
.RE
.PP
Input file instructions are read from standard input if a dash
\f[C]-\f[R] is passed as \f[C]input-file\f[R].
.PP
Fino accepts \f[I]optional extra arguments\f[R] which are then
verbatimly replaced in the input file as \f[C]$1\f[R], \f[C]$2\f[R], and
so on.
So for example if an input file has a line like this
.IP
.nf
\f[C]
MESH_FILE $1.msh
[...]
\f[R]
.fi
.PP
Then two different meshes called \f[C]one.msh\f[R] and \f[C]two.msh\f[R]
can successively be used in two runs with the same input file by calling
Fino as
.IP
.nf
\f[C]
fino input.fin one
fino input.fin two
\f[R]
.fi
.SH REFERENCE
.SS Fino keywords
.SS FINO_LINEARIZE
.RS
.PP
Performs stress linearization according to ASME VII-Sec 5 over a Stress
Classification Line
.RE
.IP
.nf
\f[C]
FINO_LINEARIZE { PHYSICAL_GROUP <physical_group> | START_POINT <x1> <y1> <z1> END_POINT <x2> <y2> <z2> }
 [ FILE <file_id> | FILE_PATH <file_path> ]
 [ TOTAL { vonmises tresca | tresca | principal1 | principal2 | principal3 }
 [ M <variable> ]
 [ MB <variable> ]
 [ PEAK <variable> ]
\f[R]
.fi
.PP
The Stress Classification Line (SCL) may be given either as a
one-dimensional physical group in the mesh or as the (continuous)
spatial coordinates of two end-points.
If the SCL is given as a \f[C]PHYSICAL_GROUP\f[R], the entity should be
one-dimensional (i.e a line) independently of the dimension of the
problem.
If the SCL is given with \f[C]START_POINT\f[R] and \f[C]END_POINT\f[R],
the number of coordinates given should match the problem dimension (i.e
three coordinates for full\ 3D problems and two coordinates for
axisymmetric or plane problems).
Coordinates can be given algebraic expressions that will be evaluated at
the time of the linearization.
If either a \f[C]FILE\f[R] or a \f[C]FILE_PATH\f[R] is given, the total,
membrane and membrane plus bending stresses are written as a function of
a scalar \f[I]t\f[R]\[u2004]\[mo]\[u2004][0,\[u2006]1].
Moreover, the individual elements of the membrane and bending stress
tensors are written within comments (i.e.\ lines starting with the hash
symbol \f[C]#\f[R]).
By default, the linearization uses the Von\ Mises criterion for the
composition of stresses.
The definition of what \f[I]total stress\f[R] means can be changed using
the \f[C]TOTAL\f[R] keyword.
The membrane, bending and peak stress tensor elements are combined using
the Von\ Mises criterion and stored as variables.
If no name for any of the variables is given, they are stored in
\f[C]M_group\f[R], \f[C]B_group\f[R] and \f[C]P_group\f[R] respectively
if there is a physical group.
Otherwise \f[C]M_1\f[R], \f[C]B_1\f[R] and \f[C]P_1\f[R] for the first
instruction, \f[C]M_2\f[R]\&... etc.
.SS FINO_PROBLEM
.RS
.PP
Sets the problem type that Fino has to solve.
.RE
.IP
.nf
\f[C]
FINO_PROBLEM [ mechanical | thermal | modal ]
 [ AXISYMMETRIC | PLANE_STRESS | PLANE_STRAIN ] [ SYMMETRY_AXIS { x | y } ] [ LINEAR | NON_LINEAR ]
 [ QUASISTATIC | TRANSIENT ]
 [ DIMENSIONS <expr> ] [ MESH <identifier> ] 
 [ N_MODES <expr> ] 
\f[R]
.fi
.IP \[bu] 2
\f[C]mechanical\f[R] (or \f[C]elastic\f[R] or \f[C]break\f[R], default)
solves the mechanical elastic problem (default).
.IP \[bu] 2
\f[C]thermal\f[R] (or \f[C]heat\f[R] or \f[C]bake\f[R]) solves the heat
conduction problem.
.IP \[bu] 2
\f[C]modal\f[R] (or \f[C]shake\f[R]) computes the natural frequencies
and oscillation modes.
.PP
If the \f[C]AXISYMMETRIC\f[R] keyword is given, the mesh is expected to
be two-dimensional in the \f[I]x\f[R]-\f[I]y\f[R] plane and the problem
is assumed to be axi-symmetric around the axis given by
\f[C]SYMMETRY_AXIS\f[R] (default is \f[I]y\f[R]).
If the problem type is mechanical and the mesh is two-dimensional on the
\f[I]x\f[R]-\f[I]y\f[R] plane and no axisymmetry is given, either
\f[C]PLANE_STRESS\f[R] and \f[C]PLAIN_STRAIN\f[R] can be provided
(default is plane stress).
By default Fino tries to detect wheter the computation should be linear
or non-linear.
An explicit mode can be set with either \f[C]LINEAR\f[R] on
\f[C]NON_LINEAR\f[R].
The number of spatial dimensions of the problem needs to be given either
with the keyword \f[C]DIMENSIONS\f[R] or by defining a \f[C]MESH\f[R]
(with an explicit \f[C]DIMENSIONS\f[R] keyword) before
\f[C]FINO_PROBLEM\f[R].
If there are more than one \f[C]MESH\f[R]es define, the one over which
the problem is to be solved can be defined by giving the explicit mesh
name with \f[C]MESH\f[R].
By default, the first mesh to be defined in the input file is the one
over which the problem is solved.
The number of modes to be computed in the modal problem.
The default is DEFAULT_NMODES.
.SS FINO_REACTION
.RS
.PP
Computes the reaction at the selected physical group.
.RE
.IP
.nf
\f[C]
FINO_REACTION PHYSICAL_GROUP <physical_group> [ { FORCE | MOMENT } ] [ {X0 | Y0 | Z0 } expr ] RESULT { <variable> | <vector> }
\f[R]
.fi
.PP
The result is stored in the variable or vector provided, depending on
the number of degrees of freedoms of the problem.
If the object passed as \f[C]RESULT\f[R] does not exist, an appropriate
object (scalar variable or vector) is created.
For the elastic problem, the components of the total reaction force are
stored in the result vector.
For the thermal problem, the total power passing through the entity is
computed as an scalar.
.SS FINO_SOLVER
.RS
.PP
Sets options related to the solver and the computation of gradients.
.RE
.IP
.nf
\f[C]
FINO_SOLVER [ PROGRESS ]
 [ PC { gamg | mumps | lu | hypre | sor | bjacobi | cholesky | ... } ]
 [ KSP { gmres | mumps | bcgs | bicg | richardson | chebyshev | ... } ]
 [ TS { bdf | arkimex | rosw | glle | beuler | ... } ]
 [ SNES_TYPE { newtonls | newtontr | nrichardson | ngmres | qn | ngs | ... } ]
 [ GRADIENT { gauss | nodes | none } ]
 [ GRADIENT_HIGHER { average | nodes } ]
 [ SMOOTH { always | never | material } ]
 [ ELEMENT_WEIGHT { volume_times_quality | volume | quality | flat } ]
\f[R]
.fi
.PP
If the keyword \f[C]PROGRESS\f[R] is given, three ASCII lines will show
in the terminal the progress of the ensamble of the stiffness matrix (or
matrices), the solution of the system of equations and the computation
of gradients (stresses).
The preconditioner, linear and non-linear solver might be any of those
available in PETSc:
.IP \[bu] 2
List of \f[C]PC\f[R]s
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/PC/PCType.html>.
.IP \[bu] 2
List of \f[C]KSP\f[R]s
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPType.html>.
.IP \[bu] 2
List of \f[C]TS\f[R]s
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSType.html>.
.IP \[bu] 2
List of \f[C]SNES\f[R]s
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESType.html>.
.PP
If either \f[C]PC\f[R] or \f[C]KSP\f[R] is set to \f[C]mumps\f[R] (and
PETSc is compiled with MUMPS support) then this direct solver is used.
For the mechanical problem, the default is to use GAMG as the
preconditioner and PETSc\[cq]s default solver (GMRES).
For the thermal problem, the default is to use the default PETSc
settings.
For the modal problem, the default is to use the default SLEPc settings.
The \f[C]GRADIENT\f[R] keyword controls how the derivatives
(i.e.\ strains) at the first-order nodes are to be computed out of the
primary unknowns (i.e.\ displacements).
.IP \[bu] 2
\f[C]gauss\f[R] (default) computes the derivatives at the gauss points
and the extrapolates the values to the nodes
.IP \[bu] 2
\f[C]nodes\f[R] computes the derivatives direcetly at the nodes
.IP \[bu] 2
\f[C]none\f[R] does not compute any derivative at all
.PP
The way derivatives are computed at high-order nodes (i.e.\ those at the
middle of edges or faces) is controlled with \f[C]GRADIENT_HIGHER\f[R]:
.IP \[bu] 2
\f[C]average\f[R] (default) assigns the plain average of the first-order
nodes that surrond each high-order node
.IP \[bu] 2
\f[C]none\f[R] computes the derivatives at the location of the
high-order nodes
.PP
The keyword \f[C]SMOOTH\f[R] controls how the gradient-based functions
(i.e.\ strains, stresses, etc) are smoothed\[em]or not\[em]to obtain
nodal values out of data which primarily comes from element-wise
evaluations at the Gauss points.
.IP \[bu] 2
\f[C]always\f[R] (default) computes a single value for each node by
averaging the contributions of individual elements.
.IP \[bu] 2
\f[C]never\f[R] keeps the contribution of each individual element
separate.
This option implies that the output mesh is different from the input
mesh as each element now has a \[lq]copy\[rq] of the original shared
nodes.
.IP \[bu] 2
\f[C]material\f[R] averages element contribution only for those elements
that belong to the same material (i.e.\ physical group).
As with \f[C]never\f[R], a new output mesh is created where the nodes
are duplicated even for those elements which belong to the same physical
group.
.PP
The way individual contributions of different elements to the same node
are averaged is controlled by \f[C]ELEMENT_WEIGHT\f[R]:
.IP \[bu] 2
\f[C]volume_times_quality\f[R] (default) weights each element by the
product of its volume times its quality
.IP \[bu] 2
\f[C]volume\f[R] weights each element by the its volume
.IP \[bu] 2
\f[C]quality\f[R] weights each element by the its quality
.IP \[bu] 2
\f[C]flat\f[R] performs plain averages (i.e.\ the same weight for all
elements)
.SS FINO_STEP
.RS
.PP
Ask Fino to solve the problem and advance one step.
.RE
.IP
.nf
\f[C]
FINO_STEP
\f[R]
.fi
.PP
The location of the \f[C]FINO_STEP\f[R] keyword within the input file
marks the logical location where the problem is solved and the result
functions (displacements, temperatures, stresses, etc.) are available
for output or further computation.
.SS Mesh keywords
.SS MATERIAL
.RS
.IP
.nf
\f[C]
MATERIAL <name> [ MESH <name> ] [ PHYSICAL_GROUP <name_1> [ PHYSICAL_GROUP <name_2> [ ... ] ] ] [ <property_name_1> <expr_1> [ <property_name_2> <expr_2> [ ... ] ] ]
\f[R]
.fi
.RE
.SS MESH
.RS
.PP
Reads an unstructured mesh from an external file in MSH, VTK or FRD
format.
.RE
.IP
.nf
\f[C]
MESH [ NAME <name> ] { FILE <file_id> | FILE_PATH <file_path> } [ DIMENSIONS <num_expr> ]
 [ SCALE <expr> ] [ OFFSET <expr_x> <expr_y> <expr_z> ]
 [ INTEGRATION { full | reduced } ] [ RE_READ ]
 [ READ_SCALAR <name_in_mesh> AS <function_name> ] [...]
 [ READ_FUNCTION <function_name> ] [...]
\f[R]
.fi
.PP
If there will be only one mesh in the input file, the \f[C]NAME\f[R] is
optional.
Yet it might be needed in cases where there are many meshes and one
needs to refer to a particular mesh, such as in \f[C]MESH_POST\f[R] or
\f[C]MESH_INTEGRATE\f[R].
When solving PDEs (such as in Fino or milonga), the first mesh is the
problem mesh.
Either a file identifier (defined previously with a \f[C]FILE\f[R]
keyword) or a file path should be given.
The format is read from the extension, which should be either
.IP \[bu] 2
\f[C].msh\f[R] Gmsh ASCII
format (http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format),
versions 2.2, 4.0 or 4.1
.IP \[bu] 2
\f[C].vtk\f[R] ASCII legacy
VTK (https://lorensen.github.io/VTKExamples/site/VTKFileFormats/)
.IP \[bu] 2
\f[C].frd\f[R] CalculiX\[cq]s FRD ASCII
output (https://web.mit.edu/calculix_v2.7/CalculiX/cgx_2.7/doc/cgx/node4.html))
.PP
Note than only MSH is suitable for defining PDE domains, as it is the
only one that provides information about physical groups.
The spatial dimensions should be given with \f[C]DIMENSION\f[R].
If material properties are uniform and given with variables, the
dimensions are not needed and will be read from the file.
But if spatial functions are needed (either for properties or read from
the mesh file), an explicit value for the mesh dimensions is needed.
If either \f[C]SCALE\f[R] or \f[C]OFFSET\f[R] are given, the node
position if first shifted and then scaled by the provided amounts.
For each \f[C]READ_SCALAR\f[R] keyword, a point-wise defined function of
space named \f[C]<function_name>\f[R] is defined and filled with the
scalar data named \f[C]<name_in_mesh>\f[R] contained in the mesh file.
The \f[C]READ_FUNCTION\f[R] keyword is a shortcut when the scalar name
and the to-be-defined function are the same.
If no \f[C]NAME\f[R] is given, the first mesh to be defined is called
\f[C]first\f[R].
.SS MESH_FILL_VECTOR
.RS
.PP
Fills the elements of a vector with data evaluated at the nodes or the
cells of a mesh.
.RE
.IP
.nf
\f[C]
MESH_FILL_VECTOR VECTOR <vector> { FUNCTION <function> | EXPRESSION <expr> } 
 [ MESH <name> ] [ NODES | CELLS ]
\f[R]
.fi
.PP
The vector to be filled needs to be already defined and to have the
appropriate size, either the number of nodes or cells of the mesh
depending on \f[C]NODES\f[R] or \f[C]CELLS\f[R] (default is nodes).
The elements of the vectors will be either the \f[C]FUNCTION\f[R] or the
\f[C]EXPRESSION\f[R] of \f[I]x\f[R], \f[I]y\f[R] and \f[I]z\f[R]
evaluated at the nodes or cells of the provided mesh.
If there is more than one mesh, the name has to be given.
.SS MESH_FIND_MINMAX
.RS
.PP
Finds absolute extrema of a function or expression within a mesh-based
domain.
.RE
.IP
.nf
\f[C]
MESH_FIND_MINMAX { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <name> ] [ OVER <physical_group_name> ] [ NODES | CELLS ]
 [ MIN <variable> ] [ MAX <variable> ]
 [ X_MIN <variable> ] [ Y_MIN <variable> ] [ Z_MIN <variable> ] [ I_MIN <variable> ]
 [ X_MAX <variable> ] [ Y_MAX <variable> ] [ Z_MAX <variable> ] [ I_MAX <variable> ]
\f[R]
.fi
.PP
Either a \f[C]FUNCTION\f[R] or an \f[C]EXPRESSION\f[R] should be given.
In the first case, just the function name is expected (i.e.\ not its
arguments).
In the second case, a full algebraic expression including the arguments
is expected.
If no explicit mesh is provided, the main mesh is used to search for the
extrema.
If the \f[C]OVER\f[R] keyword is given, the search is performed only on
the provided physical group.
Depending on the problem type, it might be needed to switch from
\f[C]NODES\f[R] to \f[C]CELLS\f[R] but this is usually not needed.
If given, the minimum (maximum) value is stored in the variable provided
by the \f[C]MIN\f[R] (\f[C]MAX\f[R]) keyword.
If given, the \f[I]x\f[R] (or \f[I]y\f[R] or \f[I]z\f[R]) coordinate of
the minimum (maximum) value is stored in the variable provided by the
\f[C]X_MIN\f[R] (or \f[C]Y_MIN\f[R] or \f[C]Z_MIN\f[R])
(\f[C]X_MAX\f[R], \f[C]Y_MAX\f[R], \f[C]Z_MAX\f[R]) keyword.
If given, the index of the minimum (maximum) value (i.e.\ the node or
cell number) is stored in the variable provided by the \f[C]I_MIN\f[R]
(\f[C]I_MAX\f[R]) keyword.
.SS MESH_INTEGRATE
.RS
.PP
Performs a spatial integration of a function or expression over a mesh.
.RE
.IP
.nf
\f[C]
MESH_INTEGRATE { FUNCTION <function> | EXPRESSION <expr> }
 [ MESH <mesh_identifier> ] [ OVER <physical_group> ] [ NODES | CELLS ]
 RESULT <variable>
\f[R]
.fi
.PP
The integrand may be either a \f[C]FUNCTION\f[R] or an
\f[C]EXPRESSION\f[R].
In the first case, just the function name is expected (i.e.\ not its
arguments).
In the second case, a full algebraic expression including the arguments
is expected.
If the expression is just \f[C]1\f[R] then the volume (or area or
length) of the domain is computed.
Note that arguments ought to be \f[C]x\f[R], \f[C]y\f[R] and/or
\f[C]z\f[R].
If there are more than one mesh defined, an explicit one has to be given
with \f[C]MESH\f[R].
By default the integration is performed over the highest-dimensional
elements of the mesh.
If the integration is to be carried out over just a physical group, it
has to be given in \f[C]OVER\f[R].
Either \f[C]NODES\f[R] or \f[C]CELLS\f[R] define how the integration is
to be performed.
In the first case a the integration is performed using the Gauss points
and weights associated to each element type.
In the second case, the integral is computed as the sum of the product
of the function evaluated at the center of each cell (element) and the
cell\[cq]s volume.
The scalar result of the integration is stored in the variable given by
\f[C]RESULT\f[R].
If the variable does not exist, it is created.
.SS MESH_MAIN
.RS
.IP
.nf
\f[C]
MESH_MAIN [ <name> ]
\f[R]
.fi
.RE
.SS MESH_POST
.RS
.IP
.nf
\f[C]
MESH_POST [ MESH <mesh_identifier> ] { FILE <name> | FILE_PATH <file_path> } [ NO_MESH ] [ FORMAT { gmsh | vtk } ] [ CELLS | ] NODES ] [ NO_PHYSICAL_NAMES ] [ VECTOR <function1_x> <function1_y> <function1_z> ] [...] [ <scalar_function_1> ] [ <scalar_function_2> ] ...
\f[R]
.fi
.RE
.SS PHYSICAL_GROUP
.RS
.PP
Defines a physical group of elements within a mesh file.
.RE
.IP
.nf
\f[C]
PHYSICAL_GROUP <name> [ MESH <name> ] [ DIMENSION <expr> ]
 [ MATERIAL <name> ]
 [ BC <bc_1> <bc_2> ... ]
\f[R]
.fi
.PP
A name is mandatory for each physical group defined within the input
file.
If there is no physical group with the provided name in the mesh, this
instruction makes no effect.
If there are many meshes, an explicit mesh can be given with
\f[C]MESH\f[R].
Otherwise, the physical group is defined on the main mesh.
An explicit dimension of the physical group can be provided with
\f[C]DIMENSION\f[R].
For volumetric elements, physical groups can be linked to materials
using \f[C]MATERIAL\f[R].
Note that if a material is created with the same name as a physical
group in the mesh, they will be linked automatically.
The \f[C]MATERIAL\f[R] keyword in \f[C]PHYSICAL_GROUP\f[R] is used to
link a physical group in a mesh file and a material in the wasora input
file with different names.
For non-volumetric elements, boundary conditions can be assigned by
using the \f[C]BC\f[R] keyword.
This should be the last keyword of the line, and any token afterwards is
treated specially by the underlying solver (i.e.\ Fino or milonga).
.SS PHYSICAL_PROPERTY
.RS
.IP
.nf
\f[C]
PHYSICAL_PROPERTY <name> [ <material_name1> <expr1> [ <material_name2> <expr2> ] ... ]
\f[R]
.fi
.RE
.SS Special input distributions
.PP
TBD.
.SS Boundary conditions
.PP
TBD.
.SS Result functions
.PP
TBD.
.SS Wasora keywords
.SS =
.RS
.PP
Assign an expression to a variable, a vector or a matrix.
.RE
.IP
.nf
\f[C]
<var>[ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <vector>(<expr_i>)[<expr_i_min, expr_i_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr> <matrix>(<expr_i>,<expr_j>)[<expr_i_min, expr_i_max; expr_j_min, expr_j_max>] [ [<expr_tmin>, <expr_tmax>] | 
<expr_t> ] = <expr>
\f[R]
.fi
.SS _.=
.RS
.PP
Add an equation to the DAE system to be solved in the phase space
spanned by \f[C]PHASE_SPACE\f[R].
.RE
.IP
.nf
\f[C]
{ 0[(i[,j]][<imin:imax[;jmin:jmax]>] | <expr1> } .= <expr2>
\f[R]
.fi
.SS ABORT
.RS
.PP
Catastrophically abort the execution and quit wasora.
.RE
.IP
.nf
\f[C]
ABORT
\f[R]
.fi
.PP
Whenever the instruction \f[C]ABORT\f[R] is executed, wasora quits
without closing files or unlocking shared memory objects.
The objective of this instruction is, as illustrated in the examples,
either to debug complex input files and check the values of certain
variables or to conditionally abort the execution using \f[C]IF\f[R]
clauses.
.SS ALIAS
.RS
.PP
Define a scalar alias of an already-defined indentifier.
.RE
.IP
.nf
\f[C]
ALIAS { <new_var_name> IS <existing_object> | <existing_object> AS <new_name> }
\f[R]
.fi
.PP
The existing object can be a variable, a vector element or a matrix
element.
In the first case, the name of the variable should be given as the
existing object.
In the second case, to alias the second element of vector \f[C]v\f[R] to
the new name \f[C]new\f[R], \f[C]v(2)\f[R] should be given as the
existing object.
In the third case, to alias second element (2,3) of matrix \f[C]M\f[R]
to the new name \f[C]new\f[R], \f[C]M(2,3)\f[R] should be given as the
existing object.
.SS CALL
.RS
.PP
Call a previously dynamically-loaded user-provided routine.
.RE
.IP
.nf
\f[C]
CALL <name> [ expr_1 expr_2 ... expr_n ]
\f[R]
.fi
.SS CLOSE
.RS
.PP
Explicitly close an already-\f[C]OPEN\f[R]ed file.
.RE
.IP
.nf
\f[C]
CLOSE
\f[R]
.fi
.SS CONST
.RS
.PP
Mark a scalar variable, vector or matrix as a constant.
.RE
.IP
.nf
\f[C]
CONST name_1 [ <name_2> ] ... [ <name_n> ]
\f[R]
.fi
.SS DEFAULT_ARGUMENT_VALUE
.RS
.PP
Give a default value for an optional commandline argument.
.RE
.IP
.nf
\f[C]
DEFAULT_ARGUMENT_VALUE <constant> <string>
\f[R]
.fi
.PP
If a \f[C]$n\f[R] construction is found in the input file but the
commandline argument was not given, the default behavior is to fail
complaining that an extra argument has to be given in the commandline.
With this keyword, a default value can be assigned if no argument is
given, thus avoiding the failure and making the argument optional.
.SS DIFFERENTIAL
.RS
.PP
Explicitly mark variables, vectors or matrices as \[lq]differential\[rq]
to compute intial conditions of DAE systems.
.RE
.IP
.nf
\f[C]
DIFFERENTIAL { <var_1> <var_2> ... | <vector_1> <vector_2> ... | <matrix_1> <matrix_2> ... }
\f[R]
.fi
.SS DO_NOT_EVALUATE_AT_PARSE_TIME
.RS
.PP
Ask wasora not to evaluate assignments at parse time.
.RE
.IP
.nf
\f[C]
DO_NOT_EVALUATE_AT_PARSE_TIME
\f[R]
.fi
.SS FILE
.RS
.PP
Define a file, either as input or as output, for further usage.
.RE
.IP
.nf
\f[C]
< FILE | OUTPUT_FILE | INPUT_FILE > <name> <printf_format> [ expr_1 expr_2 ... expr_n ] [ INPUT | OUTPUT | MODE <fopen_mode> ] [ OPEN | DO_NOT_OPEN ]
\f[R]
.fi
.SS FIT
.RS
.PP
Fit a function of one or more arguments to a set of pointwise-defined
data.
.RE
.IP
.nf
\f[C]
FIT <function_to_be_fitted> TO <function_with_data> VIA <var_1> <var_2> ... <var_n>
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ RANGE_MIN <expr_1> <expr_2> ... <expr_j> ]
 [ RANGE_MAX <expr_1> <expr_2> ... <expr_n> ]
 [ DELTAEPSREL <expr> ] [ DELTAEPSABS <expr> ] [ MAX_ITER <expr> ]
 [ VERBOSE ] [ RERUN | DO_NOT_RERUN ]
\f[R]
.fi
.PP
The function with the data has to be point-wise defined (i.e.\ a
\f[C]FUNCTION\f[R] read from a file with inline \f[C]DATA\f[R]).
The function to be fitted has to be parametrized with at least one of
the variables provided after the \f[C]VIA\f[R] keyword.
Only the names of the functions have to be given, not the arguments.
Both functions have to have the same number of arguments.
The initial guess of the solution is given by the initial value of the
variables listed in the \f[C]VIA\f[R] keyword.
Analytical expressions for the gradient of the function to be fitted
with respect to the parameters to be fitted can be optionally given with
the \f[C]GRADIENT\f[R] keyword.
If none is provided, the gradient will be computed numerically using
finite differences.
A range over which the residuals are to be minimized can be given with
\f[C]RANGE_MIN\f[R] and \f[C]RANGE_MAX\f[R].
The expressions give the range of the arguments of the functions, not of
the parameters.
For multidimensional fits, the range is an hypercube.
If no range is given, all the definition points of the function with the
data are used for the fit.
Convergence can be controlled by giving the relative and absolute
tolreances with \f[C]DELTAEPSREL\f[R] (default \f[C]1e-4\f[R]) and
\f[C]DELTAEPSABS\f[R] (default \f[C]1e-6\f[R]), and with the maximum
number of iterations \f[C]MAX_ITER\f[R] (default 100).
If the optional keyword \f[C]VERBOSE\f[R] is given, some data of the
intermediate steps is written in the standard output.
The combination of arguments that minimize the function are computed and
stored in the variables.
So if \f[C]f(x,y)\f[R] is to be minimized, after a \f[C]MINIMIZE f\f[R]
both \f[C]x\f[R] and \f[C]y\f[R] would have the appropriate values.
The details of the method used can be found in GSL\[cq]s
documentation (https://www.gnu.org/software/gsl/doc/html/multimin.html).
Some of them use derivatives and some of them do not.
Default method is \f[C]gsl_multimin_fminimizer_nmsimplex2\f[R], which
does not need derivatives.
.SS FUNCTION
.RS
.PP
Define a function of one or more variables.
.RE
.IP
.nf
\f[C]
FUNCTION <name>(<var_1>[,var2,...,var_n]) { [ = <expr> | FILE_PATH <file_path> | ROUTINE <name> | | MESH <name> { DATA <new_vector_name> | VECTOR <existing_vector_name> } { NODES | CELLS } | [ VECTOR_DATA <vector_1> <vector_2> ... <vector_n> <vector_n+1> ] } [COLUMNS <expr_1> <expr_2> ... <expr_n> <expr_n+1> ] [ INTERPOLATION { linear | polynomial | spline | spline_periodic | akima | akima_periodic | steffen | nearest | shepard | shepard_kd | bilinear } ] [ INTERPOLATION_THRESHOLD <expr> ] [ SHEPARD_RADIUS <expr> ] [ SHEPARD_EXPONENT <expr> ] [ SIZES <expr_1> <expr_2> ... <expr_n> ] [ X_INCREASES_FIRST <expr> ] [ DATA <num_1> <num_2> ... <num_N> ]
\f[R]
.fi
.PP
The number of variables \f[I]n\f[R] is given by the number of arguments
given between parenthesis after the function name.
The arguments are defined as new variables if they had not been already
defined as variables.
If the function is given as an algebraic expression, the short-hand
operator \f[C]:=\f[R] can be used.
That is to say, \f[C]FUNCTION f(x) = x\[ha]2\f[R] is equivalent to
\f[C]f(x) := x\[ha]2\f[R].
If a \f[C]FILE_PATH\f[R] is given, an ASCII file containing at least
\f[I]n\f[R]\[u2005]+\[u2005]1 columns is expected.
By default, the first \f[I]n\f[R] columns are the values of the
arguments and the last column is the value of the function at those
points.
The order of the columns can be changed with the keyword
\f[C]COLUMNS\f[R], which expects \f[I]n\f[R]\[u2005]+\[u2005]1
expressions corresponding to the column numbers.
A function of type \f[C]ROUTINE\f[R] calls an already-defined
user-provided routine using the \f[C]CALL\f[R] keyword and passes the
values of the variables in each required evaluation as a
\f[C]double *\f[R] argument.
If \f[C]MESH\f[R] is given, the definition points are the nodes or the
cells of the mesh.
The function arguments should be (\f[I]x\f[R]),
(\f[I]x\f[R],\[u2006]\f[I]y\f[R]) or
(\f[I]x\f[R],\[u2006]\f[I]y\f[R],\[u2006]\f[I]z\f[R]) matching the
dimension the mesh.
If the keyword \f[C]DATA\f[R] is used, a new empty vector of the
appropriate size is defined.
The elements of this new vector can be assigned to the values of the
function at the \f[I]i\f[R]-th node or cell.
If the keyword \f[C]VECTOR\f[R] is used, the values of the dependent
variable are taken to be the values of the already-existing vector.
Note that this vector should have the size of the number of nodes or
cells the mesh has, depending on whether \f[C]NODES\f[R] or
\f[C]CELLS\f[R] is given.
If \f[C]VECTOR_DATA\f[R] is given, a set of
\f[I]n\f[R]\[u2005]+\[u2005]1 vectors of the same size is expected.
The first \f[I]n\f[R]\[u2005]+\[u2005]1 correspond to the arguments and
the last one is the function value.
Interpolation schemes can be given for either one or multi-dimensional
functions with \f[C]INTERPOLATION\f[R].
Available schemes for \f[I]n\f[R]\[u2004]=\[u2004]1 are:
.IP \[bu] 2
linear
.IP \[bu] 2
polynomial, the grade is equal to the number of data minus one
.IP \[bu] 2
spline, cubic (needs at least 3 points)
.IP \[bu] 2
spline_periodic
.IP \[bu] 2
akima (needs at least 5 points)
.IP \[bu] 2
akima_periodic (needs at least 5 points)
.IP \[bu] 2
steffen, always-monotonic splines-like (available only with GSL >= 2.0)
.PP
Default interpolation scheme for one-dimensional functions is
\f[C](*gsl_interp_linear)\f[R].
.PP
Available schemes for \f[I]n\f[R]\[u2004]>\[u2004]1 are:
.IP \[bu] 2
nearest, \f[I]f\f[R](\f[I]x\[u20D7]\f[R]) is equal to the value of the
closest definition point
.IP \[bu] 2
shepard, inverse distance weighted average definition
points (https://en.wikipedia.org/wiki/Inverse_distance_weighting) (might
lead to inefficient evaluation)
.IP \[bu] 2
shepard_kd, average of definition points within a
kd-tree (https://en.wikipedia.org/wiki/Inverse_distance_weighting#Modified_Shepard's_method)
(more efficient evaluation provided \f[C]SHEPARD_RADIUS\f[R] is set to a
proper value)
.IP \[bu] 2
bilinear, only available if the definition points configure an
structured hypercube-like grid.
If \f[I]n\f[R]\[u2004]>\[u2004]3, \f[C]SIZES\f[R] should be given.
.PP
For \f[I]n\f[R]\[u2004]>\[u2004]1, if the euclidean distance between the
arguments and the definition points is smaller than
\f[C]INTERPOLATION_THRESHOLD\f[R], the definition point is returned and
no interpolation is performed.
Default value is square root of \f[C]9.5367431640625e-07\f[R].
The initial radius of points to take into account in
\f[C]shepard_kd\f[R] is given by \f[C]SHEPARD_RADIUS\f[R].
If no points are found, the radius is double until at least one
definition point is found.
The radius is doubled until at least one point is found.
Default is \f[C]1.0\f[R].
The exponent of the \f[C]shepard\f[R] method is given by
\f[C]SHEPARD_EXPONENT\f[R].
Default is \f[C]2\f[R].
When requesting \f[C]bilinear\f[R] interpolation for
\f[I]n\f[R]\[u2004]>\[u2004]3, the number of definition points for each
argument variable has to be given with \f[C]SIZES\f[R], and wether the
definition data is sorted with the first argument changing first
(\f[C]X_INCREASES_FIRST\f[R] evaluating to non-zero) or with the last
argument changing first (zero).
The function can be pointwise-defined inline in the input using
\f[C]DATA\f[R].
This should be the last keyword of the line, followed by
\f[I]N\f[R]\[u2004]=\[u2004]\f[I]k\f[R]\[u2005]\[md]\[u2005](\f[I]n\f[R]\[u2005]+\[u2005]1)
expresions giving \f[I]k\f[R] definition points: \f[I]n\f[R] arguments
and the value of the function.
Multiline continuation using brackets \f[C]{\f[R] and \f[C]}\f[R] can be
used for a clean data organization.
See the examples.
.SS HISTORY
.RS
.PP
Record the time history of a variable as a function of time.
.RE
.IP
.nf
\f[C]
HISTORY <variable> <function>
\f[R]
.fi
.SS IF
.RS
.PP
Begin a conditional block.
.RE
.IP
.nf
\f[C]
IF expr
<block_of_instructions_if_expr_is_true>
[ ELSE ]
[block_of_instructions_if_expr_is_false]
ENDIF
\f[R]
.fi
.SS IMPLICIT
.RS
.PP
Define whether implicit declaration of variables is allowed or not.
.RE
.IP
.nf
\f[C]
IMPLICIT { NONE | ALLOWED }
\f[R]
.fi
.PP
By default, wasora allows variables (but not vectors nor matrices) to be
implicitly declared.
To avoid introducing errors due to typos, explicit declaration of
variables can be forced by giving \f[C]IMPLICIT NONE\f[R].
Whether implicit declaration is allowed or explicit declaration is
required depends on the last \f[C]IMPLICIT\f[R] keyword given, which by
default is \f[C]ALLOWED\f[R].
.SS INCLUDE
.RS
.PP
Include another wasora input file.
.RE
.IP
.nf
\f[C]
INCLUDE <file_path> [ FROM <num_expr> ] [ TO <num_expr> ]
\f[R]
.fi
.PP
Includes the input file located in the string \f[C]file_path\f[R] at the
current location.
The effect is the same as copying and pasting the contents of the
included file at the location of the \f[C]INCLUDE\f[R] keyword.
The path can be relative or absolute.
Note, however, that when including files inside \f[C]IF\f[R] blocks that
instructions are conditionally-executed but all definitions (such as
function definitions) are processed at parse-time independently from the
evaluation of the conditional.
The optional \f[C]FROM\f[R] and \f[C]TO\f[R] keywords can be used to
include only portions of a file.
.SS INITIAL_CONDITIONS_MODE
.RS
.PP
Define how initial conditions of DAE problems are computed.
.RE
.IP
.nf
\f[C]
INITIAL_CONDITIONS_MODE { AS_PROVIDED | FROM_VARIABLES | FROM_DERIVATIVES }
\f[R]
.fi
.PP
In DAE problems, initial conditions may be either:
.IP \[bu] 2
equal to the provided expressions (\f[C]AS_PROVIDED\f[R])
.IP \[bu] 2
the derivatives computed from the provided phase-space variables
(\f[C]FROM_VARIABLES\f[R])
.IP \[bu] 2
the phase-space variables computed from the provided derivatives
(\f[C]FROM_DERIVATIVES\f[R])
.PP
In the first case, it is up to the user to fulfill the DAE system
at\ \f[I]t\f[R]\[u2004]=\[u2004]0.
If the residuals are not small enough, a convergence error will occur.
The \f[C]FROM_VARIABLES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter
\f[C]IDA_YA_YDP_INIT\f[R].
The \f[C]FROM_DERIVATIVES\f[R] option means calling IDA\[cq]s
\f[C]IDACalcIC\f[R] routine with the parameter IDA_Y_INIT.
Wasora should be able to automatically detect which variables in
phase-space are differential and which are purely algebraic.
However, the \f[C]DIFFERENTIAL\f[R] keyword may be used to explicitly
define them.
See the (SUNDIALS
documentation)[https://computation.llnl.gov/casc/sundials/documentation/ida_guide.pdf]
for further information.
.SS LOAD_PLUGIN
.RS
.PP
Load a wasora plug-in from a dynamic shared object.
.RE
.IP
.nf
\f[C]
LOAD_PLUGIN { <file_path> | <plugin_name> }
\f[R]
.fi
.PP
A wasora plugin in the form of a dynamic shared object
(i.e.\ \f[C].so\f[R]) can be loaded either with the
\f[C]LOAD_PLUGIN\f[R] keyword or from the command line with the
\f[C]-p\f[R] option.
Either a file path or a plugin name can be given.
The following locations are tried:
.IP \[bu] 2
the current directory \f[C]./\f[R]
.IP \[bu] 2
the parent directory \f[C]../\f[R]
.IP \[bu] 2
the user\[cq]s \f[C]LD_LIBRARY_PATH\f[R]
.IP \[bu] 2
the cache file \f[C]/etc/ld.so.cache\f[R]
.IP \[bu] 2
the directories \f[C]/lib\f[R], \f[C]/usr/lib\f[R],
\f[C]/usr/local/lib\f[R]
.PP
If a wasora plugin was compiled and installed following the
\f[C]make install\f[R] procedure, the plugin should be loaded by just
passing the name to \f[C]LOAD_PLUGIN\f[R].
.SS LOAD_ROUTINE
.RS
.PP
Load one or more routines from a dynamic shared object.
.RE
.IP
.nf
\f[C]
LOAD_ROUTINE <file_path> <routine_1> [ <routine_2> ... <routine_n> ]
\f[R]
.fi
.SS M4
.RS
.PP
Call the \f[C]m4\f[R] macro processor with definitions from wasora
variables or expressions.
.RE
.IP
.nf
\f[C]
M4 { INPUT_FILE <file_id> | FILE_PATH <file_path> } { OUTPUT_FILE <file_id> | OUTPUT_FILE_PATH <file_path> } [ EXPAND <name> ] ... } [ MACRO <name> [ <format> ] <definition> ] ... }
\f[R]
.fi
.SS MATRIX
.RS
.PP
Define a matrix.
.RE
.IP
.nf
\f[C]
MATRIX <name> ROWS <expr> COLS <expr> [ DATA num_expr_1 num_expr_2 ... num_expr_n ]
\f[R]
.fi
.SS MINIMIZE
.RS
.PP
Find the combination of arguments that give a (relative) minimum of a
function.
.RE
.IP
.nf
\f[C]
MINIMIZE <function>
 [ METHOD { nmsimplex2 | nmsimplex | nmsimplex2rand | conjugate_fr | conjugate_pr | vector_bfgs2 | vector_bfgs | steepest_descent}
 [ GRADIENT <expr_1> <expr_2> ... <expr_n> ]
 [ GUESS <expr_1> <expr_2> ... <expr_n> ]
 [ MIN <expr_1> <expr_2> ... <expr_n> ]
 [ MAX <expr_1> <expr_2> ... <expr_n> ]
 [ STEP <expr_1> <expr_2> ... <expr_n> ]
 [ MAX_ITER <expr> ] [ TOL <expr> ] [ GRADTOL <expr> ]
 [ VERBOSE ] [ NORERUN ]
\f[R]
.fi
.SS PARAMETRIC
.RS
.PP
Systematically sweep a zone of the parameter space, i.e.\ perform a
parametric run.
.RE
.IP
.nf
\f[C]
PARAMETRIC <var_1> [ ... <var_n> ] [ TYPE { linear | logarithmic | random | gaussianrandom | sobol | niederreiter | halton | reversehalton } ] [ MIN <num_expr_1> ... <num_expr_n> ] [ MAX <num_expr_1> ... <num_expr_n> ] [ STEP <num_expr_1> ... <num_expr_n> ] [ NSTEPS <num_expr_1> ... <num_expr_n> ] [ OUTER_STEPS <num_expr> ] [ MAX_DAUGHTERS <num_expr> ] [ OFFSET <num_expr> ] [ ADIABATIC ]
\f[R]
.fi
.SS PHASE_SPACE
.RS
.PP
Define which variables, vectors and/or matrices belong to the phase
space of the DAE system to be solved.
.RE
.IP
.nf
\f[C]
PHASE_SPACE { <vars> | <vectors> | <matrices> }
\f[R]
.fi
.SS PRINT
.RS
.PP
Print plain-text and/or formatted data to the standard output or into an
output file.
.RE
.IP
.nf
\f[C]
PRINT [ FILE <file_id> | FILE_PATH <file_path> ] [ NONEWLINE ] [ SEP <string> ] [ NOSEP ] [ HEADER ] [ SKIP_STEP <expr> ] [ SKIP_STATIC_STEP <expr> ] [ SKIP_TIME <expr> ] [ SKIP_HEADER_STEP <expr> ] [ <object_1> <object_2> ... <object_n> ] [ TEXT <string_1> ... TEXT <string_n> ]
\f[R]
.fi
.PP
Each argument \f[C]object\f[R] that is not a keyword is expected to be
part of the output, can be either a matrix, a vector, an scalar
algebraic expression.
If the given object cannot be solved into a valid matrix, vector or
expression, it is treated as a string literal if \f[C]IMPLICIT\f[R] is
\f[C]ALLOWED\f[R], otherwise a parser error is raised.
To explicitly interpret an object as a literal string even if it
resolves to a valid numerical expression, it should be prefixed with the
\f[C]TEXT\f[R] keyword.
Hashes \f[C]#\f[R] appearing literal in text strings have to be quoted
to prevent the parser to treat them as comments within the wasora input
file and thus ignoring the rest of the line.
Whenever an argument starts with a porcentage sign \f[C]%\f[R], it is
treated as a C \f[C]printf\f[R]-compatible format definition and all the
objects that follow it are printed using the given format until a new
format definition is found.
The objects are treated as double-precision floating point numbers, so
only floating point formats should be given.
The default format is \f[C]\[dq]%g\[dq]\f[R].
Matrices, vectors, scalar expressions, format modifiers and string
literals can be given in any desired order, and are processed from left
to right.
Vectors are printed element-by-element in a single row.
See \f[C]PRINT_VECTOR\f[R] to print vectors column-wise.
Matrices are printed element-by-element in a single line using row-major
ordering if mixed with other objects but in the natural row and column
fashion if it is the only given object.
If the \f[C]FILE\f[R] keyword is not provided, default is to write to
stdout.
If the \f[C]NONEWLINE\f[R] keyword is not provided, default is to write
a newline \f[C]\[rs]n\f[R] character after all the objects are
processed.
The \f[C]SEP\f[R] keywords expects a string used to separate printed
objects, the default is a tab `DEFAULT_PRINT_SEPARATOR' character.
Use the \f[C]NOSEP\f[R] keyword to define an empty string as object
separator.
If the \f[C]HEADER\f[R] keyword is given, a single line containing the
literal text given for each object is printed at the very first time the
\f[C]PRINT\f[R] instruction is processed, starting with a hash
\f[C]#\f[R] character.
If the \f[C]SKIP_STEP\f[R] (\f[C]SKIP_STATIC_STEP\f[R])keyword is given,
the instruction is processed only every the number of transient (static)
steps that results in evaluating the expression, which may not be
constant.
By default the \f[C]PRINT\f[R] instruction is evaluated every step.
The \f[C]SKIP_HEADER_STEP\f[R] keyword works similarly for the optional
\f[C]HEADER\f[R] but by default it is only printed once.
The \f[C]SKIP_TIME\f[R] keyword use time advancements to choose how to
skip printing and may be useful for non-constant time-step problems.
.SS PRINT_FUNCTION
.RS
.PP
Print one or more functions as a table of values of dependent and
independent variables.
.RE
.IP
.nf
\f[C]
PRINT_FUNCTION <function_1> [ { function_2 | expr_1 } ... { function_n | expr_n-1 } ] [ FILE <file_id> | FILE_PATH <file_path> ] [ HEADER ] [ MIN <expr_1> <expr_2> ... <expr_m> ] [ MAX <expr_1> <expr_2> ... <expr_m> ] [ STEP <expr_1> <expr_2> ... <expr_m> ] [ NSTEPs <expr_1> <expr_2> ... <expr_m> ] [ FORMAT <print_format> ] [ PHYSICAL_ENTITY <name> ]
\f[R]
.fi
.SS PRINT_VECTOR
.RS
.PP
Print the elements of one or more vectors.
.RE
.IP
.nf
\f[C]
PRINT_VECTOR [ FILE <file_id> ] FILE_PATH <file_path> ] [ { VERTICAL | HORIZONTAL } ] [ ELEMS_PER_LINE <expr> ] [ FORMAT <print_format> ] <vector_1> [ vector_2 ... vector_n ]
\f[R]
.fi
.SS READ
.RS
.PP
Read data (variables, vectors o matrices) from files or shared-memory
segments.
.RE
.IP
.nf
\f[C]
[ READ | WRITE ] [ SHM <name> ] [ { ASCII_FILE_PATH | BINARY_FILE_PATH } <file_path> ] [ { ASCII_FILE | BINARY_FILE } <identifier> ] [ IGNORE_NULL ] [ object_1 object_2 ... object_n ]
\f[R]
.fi
.SS SEMAPHORE
.RS
.PP
Perform either a wait or a post operation on a named shared semaphore.
.RE
.IP
.nf
\f[C]
[ SEMAPHORE | SEM ] <name> { WAIT | POST }
\f[R]
.fi
.SS SHELL
.RS
.PP
Execute a shell command.
.RE
.IP
.nf
\f[C]
SHELL <print_format> [ expr_1 expr_2 ... expr_n ]
\f[R]
.fi
.SS SOLVE
.RS
.PP
Solve a non-linear system of\ \f[I]n\f[R] equations with\ \f[I]n\f[R]
unknowns.
.RE
.IP
.nf
\f[C]
SOLVE <n> UNKNOWNS <var_1> <var_2> ... <var_n> RESIDUALS <expr_1> <expr_2> ... <expr_n> ] GUESS <expr_1> <expr_2> ... <expr_n> ] [ METHOD { dnewton | hybrid | hybrids | broyden } ] [ EPSABS <expr> ] [ EPSREL <expr> ] [ MAX_ITER <expr> ] [ VERBOSE ]
\f[R]
.fi
.SS TIME_PATH
.RS
.PP
Force transient problems to pass through specific instants of time.
.RE
.IP
.nf
\f[C]
TIME_PATH <expr_1> [ <expr_2> [ ... <expr_n> ] ]
\f[R]
.fi
.PP
The time step \f[C]dt\f[R] will be reduced whenever the distance between
the current time \f[C]t\f[R] and the next expression in the list is
greater than \f[C]dt\f[R] so as to force \f[C]t\f[R] to coincide with
the expressions given.
The list of expresssions should evaluate to a sorted list of values.
.SS VAR
.RS
.PP
Define one or more scalar variables.
.RE
.IP
.nf
\f[C]
VAR <name_1> [ <name_2> ] ... [ <name_n> ]
\f[R]
.fi
.SS VECTOR
.RS
.PP
Define a vector.
.RE
.IP
.nf
\f[C]
VECTOR <name> SIZE <expr> [ DATA <expr_1> <expr_2> ... <expr_n> | FUNCTION_DATA <function> ]
\f[R]
.fi
.SS VECTOR_SORT
.RS
.PP
Sort the elements of a vector using a specific numerical order,
potentially making the same rearrangement of another vector.
.RE
.IP
.nf
\f[C]
VECTOR_SORT <vector> [ ASCENDING_ORDER | DESCENDING_ORDER ] [ <vector> ]
\f[R]
.fi
.SS WRITE
.RS
.PP
Write data (variables, vectors o matrices) to files or shared-memory
segments.
See the \f[C]READ\f[R] keyword for usage details.
.RE
.SS Fino variables
.SS delta_sigma_max
.RS
.RE
.PP
The uncertainty of the maximum Von\ Mises stress\ \f[I]\[*s]\f[R] of the
elastic problem.
Not to be confused with the maximum uncertainty of the Von\ Mises
stress.
.SS displ_max
.RS
.RE
.PP
The module of the maximum displacement of the elastic problem.
.SS displ_max_x
.RS
.RE
.PP
The\ \f[I]x\f[R] coordinate of the maximum displacement of the elastic
problem.
.SS displ_max_y
.RS
.RE
.PP
The\ \f[I]y\f[R] coordinate of the maximum displacement of the elastic
problem.
.SS displ_max_z
.RS
.RE
.PP
The\ \f[I]z\f[R] coordinate of the maximum displacement of the elastic
problem.
.SS fino_abstol
.RS
.RE
.PP
Absolute tolerance of the linear solver, as passed to PETSc\[cq]s
[\f[C]KSPSetTolerances\f[R]](http: Default \f[C]1e-50\f[R].
.SS fino_divtol
.RS
.RE
.PP
Divergence tolerance, as passed to PETSc\[cq]s
[\f[C]KSPSetTolerances\f[R]](http: Default \f[C]1e+4\f[R].
.SS fino_gamg_threshold
.RS
.RE
.PP
Relative threshold to use for dropping edges in aggregation graph for
the [Geometric Algebraic Multigrid Preconditioner](http: as passed to
PETSc\[cq]s [\f[C]PCGAMGSetThreshold\f[R]](http: A value of 0.0 means
keep all nonzero entries in the graph; negative means keep even zero
entries in the graph.
Default \f[C]0.01\f[R].
.SS fino_iterations
.RS
.RE
.PP
This variable contains the actual number of iterations used by the
solver.
It is set after \f[C]FINO_STEP\f[R].
.SS fino_max_iterations
.RS
.RE
.PP
Number of maximum iterations before diverging, as passed to PETSc\[cq]s
[\f[C]KSPSetTolerances\f[R]](http: Default \f[C]10000\f[R].
.SS fino_penalty_weight
.RS
.RE
.PP
The weight \f[I]w\f[R] used when setting multi-freedom boundary
conditions.
Higher values mean better precision in the constrain but distort the
matrix condition number.
Default is \f[C]1e8\f[R].
.SS fino_reltol
.RS
.RE
.PP
Relative tolerance of the linear solver, as passed to PETSc\[cq]s
[\f[C]KSPSetTolerances\f[R]](http: Default \f[C]1e-6\f[R].
.SS fino_residual_norm
.RS
.RE
.PP
This variable contains the residual obtained by the solver.
It is set after \f[C]FINO_STEP\f[R].
.SS lambda
.RS
.RE
.PP
Requested eigenvalue.
It is equal to 1.0 until \f[C]FINO_STEP\f[R] is executed.
.SS memory
.RS
.RE
.PP
Maximum resident set size (global memory used), in bytes.
.SS memory_available
.RS
.RE
.PP
Total available memory, in bytes.
.SS memory_petsc
.RS
.RE
.PP
Maximum resident set size (memory used by PETSc), in bytes.
.SS nodes_rough
.RS
.RE
.PP
The number of nodes of the mesh in \f[C]ROUGH\f[R] mode.
.SS petsc_flops
.RS
.RE
.PP
Number of floating point operations performed by PETSc/SLEPc.
.SS sigma_max
.RS
.RE
.PP
The maximum von Mises stress\ \f[I]\[*s]\f[R] of the elastic problem.
.SS sigma_max_x
.RS
.RE
.PP
The\ \f[I]x\f[R] coordinate of the maximum von Mises
stress\ \f[I]\[*s]\f[R] of the elastic problem.
.SS sigma_max_y
.RS
.RE
.PP
The\ \f[I]x\f[R] coordinate of the maximum von Mises
stress\ \f[I]\[*s]\f[R] of the elastic problem.
.SS sigma_max_z
.RS
.RE
.PP
The\ \f[I]x\f[R] coordinate of the maximum von Mises
stress\ \f[I]\[*s]\f[R] of the elastic problem.
.SS strain_energy
.RS
.RE
.PP
The strain energy stored in the solid, computed as
1/2\[u2005]\[md]\[u2005]\f[I]u\[u20D7]\f[R]^\f[I]T\f[R]^\f[I]K\f[R]\f[I]u\[u20D7]\f[R]
where \f[I]u\[u20D7]\f[R] is the displacements vector and \f[I]K\f[R] is
the stiffness matrix.
.SS time_cpu_build
.RS
.RE
.PP
CPU time insumed to build the problem matrices, in seconds.
.SS time_cpu_solve
.RS
.RE
.PP
CPU time insumed to solve the problem, in seconds.
.SS time_cpu_stress
.RS
.RE
.PP
CPU time insumed to compute the stresses from the displacements, in
seconds.
.SS time_petsc_build
.RS
.RE
.PP
CPU time insumed by PETSc to build the problem matrices, in seconds.
.SS time_petsc_solve
.RS
.RE
.PP
CPU time insumed by PETSc to solve the eigen-problem, in seconds.
.SS time_petsc_stress
.RS
.RE
.PP
CPU time insumed by PETSc to compute the stresses, in seconds.
.SS time_wall_build
.RS
.RE
.PP
Wall time insumed to build the problem matrices, in seconds.
.SS time_wall_solve
.RS
.RE
.PP
Wall time insumed to solve the problem, in seconds.
.SS time_wall_stress
.RS
.RE
.PP
Wall time insumed to compute the stresses, in seconds.
.SS time_wall_total
.RS
.RE
.PP
Wall time insumed to initialize, build and solve, in seconds.
CPU time insumed to initialize, build and solve, in seconds.
CPU time insumed by PETSc to initialize, build and solve, in seconds.
.SS T_max
.RS
.RE
.PP
The maximum temperature\ \f[I]T\f[R]~max~ of the thermal problem.
.SS T_min
.RS
.RE
.PP
The minimum temperature\ \f[I]T\f[R]~min~ of the thermal problem.
.SS u_at_displ_max
.RS
.RE
.PP
The\ \f[I]x\f[R] component\ \f[I]u\f[R] of the maximum displacement of
the elastic problem.
.SS u_at_sigma_max
.RS
.RE
.PP
The\ \f[I]x\f[R] component\ \f[I]u\f[R] of the displacement where the
maximum von Mises stress\ \f[I]\[*s]\f[R] of the elastic problem is
located.
.SS v_at_displ_max
.RS
.RE
.PP
The\ \f[I]y\f[R] component\ \f[I]v\f[R] of the maximum displacement of
the elastic problem.
.SS v_at_sigma_max
.RS
.RE
.PP
The\ \f[I]y\f[R] component\ \f[I]v\f[R] of the displacement where the
maximum von Mises stress\ \f[I]\[*s]\f[R] of the elastic problem is
located.
.SS w_at_displ_max
.RS
.RE
.PP
The\ \f[I]z\f[R] component\ \f[I]w\f[R] of the maximum displacement of
the elastic problem.
.SS w_at_sigma_max
.RS
.RE
.PP
The\ \f[I]z\f[R] component\ \f[I]w\f[R] of the displacement where the
maximum von Mises stress\ \f[I]\[*s]\f[R] of the elastic problem is
located.
.SH SEE ALSO
.PP
\f[C]gmsh\f[R](1), \f[C]paraview\f[R](1)
.PP
The Fino Case files at <https://www.seamplex.com/fino/cases/> contains
fully-discussed examples.
.PP
The Fino web page contains full source code, updates, examples, V&V
cases and full reference: <https://www.seamplex.com/fino>.
.SH AUTHOR
.PP
Jeremy Theler <https://www.seamplex.com>
.SH AUTHORS
Jeremy Theler.
